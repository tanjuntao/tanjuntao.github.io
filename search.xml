<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何删除github仓库中某个文件或者文件夹]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4github%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[从远处clone仓库到本地在本地任意找一个文件夹，鼠标右键打开git bash，将远程仓库clone到此文件夹下面。1git clone &lt;仓库的git地址&gt; 进入到仓库目录中1cd &lt;仓库名&gt; 删除文件夹如果文件夹名称是单独的英文单词，不带有空格，那么输入：1git rm -r &lt;文件夹名&gt; 如果文件夹名称是中文名或者带有多个英文单词但是使用空格分隔，那么输入1git rm -r &apos;&lt;文件夹名&gt;&apos; # 同前面的区别是多了单引号，可以使用tab补全文件夹名称 删除文件如果只是删除某个特定文件的话：1git rm &lt;文件名全程&gt; # 包含文件名+后缀 如果需要批量删除某类后缀名的文件1git rm *.&lt;后缀名&gt; # e.g. git rm *.md 将修改提交到远程仓库123git add *git commit -m &quot;输入提示信息&quot;git push origin master 搞定！]]></content>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld of Keras]]></title>
    <url>%2F2019%2F05%2F17%2FHelloWorld-of-Keras%2F</url>
    <content type="text"><![CDATA[mnist_cnn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf8 -*-# "Hello World" of Keras in image classification taskfrom __future__ import print_function # 在Python2的代码中可以使用Python3的print函数，即需要加上括号import kerasfrom keras.datasets import mnistfrom keras.models import Sequential # 序列模型，可以封装各种网络层: 卷积层、池化层、全连接层、dropout等from keras.layers import Dense, Dropout, Flattenfrom keras.layers import Conv2D, MaxPooling2Dfrom keras import backend as K # Keras是一个高层API，后端使用TensorFlow或者Theanobatch_size = 128num_classes = 10epochs = 12 # 12个epoch足够训练好模型img_rows, img_cols = 28, 28 # mnist dataset中image的大小# 如果第一次跑，会通过url方式从amazon下载mnist.npz；如果已经下载过了，那么直接加载本地mnist.npz(x_train, y_train), (x_test, y_test) = mnist.load_data()# 根据不同的后端，将图片转换为不同的格式，TensorFlow是channel_lastif K.image_data_format() == 'channels_first': x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols) # 通道为1 x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols) input_shape = (1, img_rows, img_cols)else: x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1) x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1) input_shape = (img_rows, img_cols, 1)# 将每个pixel的类型从integer转为float32，使计算更加精确x_train = x_train.astype('float32')x_test = x_test.astype('float32')# 将0-255范围的pixel值转化到0-1x_train /= 255x_test /= 255# 如果后端是TensorFlowprint('x_train shape:', x_train.shape) # 输出(60000, 28, 28, 1)print(x_train.shape[0], 'train samples') # 输出60000print(x_test.shape[0], 'test samples') # 输出10000# 每个y_train或者y_test本来是一个整数表示每一类，现转换为one-hot encodingy_train = keras.utils.to_categorical(y_train, num_classes)y_test = keras.utils.to_categorical(y_test, num_classes)# 实例化一个序列模型model = Sequential()# Conv1model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=input_shape))# Conv2model.add(Conv2D(64, (3, 3), activation='relu'))# Pool1model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.5))# 将maxpooling后的64个activation map 全部拉伸为一个向量model.add(Flatten())model.add(Dense(128, activation='relu'))model.add(Dropout(0.5))# 用softmax函数将logits转为每个类别的概率model.add(Dense(10, activation='softmax'))# 设置损失函数，优化器，度量标准model.compile(loss=keras.losses.categorical_crossentropy, optimizer=keras.optimizers.Adadelta(), metrics=['accuracy'])# 训练模型# verbose=1 展示详细的训练过程# verbose=0 只显示最后结果，不展示过程# verbose=2 每个epoch输出一条信息，不展示详细的训练过程# validation_data会在每个每个epoch结束后计算当前模型的准确率，validation_data不参与训练model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=2, validation_data=(x_test, y_test))# 在测试集上测试模型效果score = model.evaluate(x_test, y_test, verbose=0)print('Test loss:', score[0])print('Test Accuracy:', score[1]) 训练过程123456789101112131415161718192021222324252627282930313233x_train shape: (60000, 28, 28, 1)60000 train samples10000 test samplesTrain on 60000 samples, validate on 10000 samplesEpoch 1/12 - 248s - loss: 0.2778 - acc: 0.9140 - val_loss: 0.0612 - val_acc: 0.9800Epoch 2/12 - 219s - loss: 0.0982 - acc: 0.9708 - val_loss: 0.0433 - val_acc: 0.9857Epoch 3/12 - 212s - loss: 0.0766 - acc: 0.9776 - val_loss: 0.0354 - val_acc: 0.9876Epoch 4/12 - 226s - loss: 0.0653 - acc: 0.9806 - val_loss: 0.0342 - val_acc: 0.9879Epoch 5/12 - 221s - loss: 0.0573 - acc: 0.9828 - val_loss: 0.0307 - val_acc: 0.9896Epoch 6/12 - 230s - loss: 0.0539 - acc: 0.9834 - val_loss: 0.0286 - val_acc: 0.9907Epoch 7/12 - 224s - loss: 0.0490 - acc: 0.9850 - val_loss: 0.0280 - val_acc: 0.9901Epoch 8/12 - 229s - loss: 0.0475 - acc: 0.9856 - val_loss: 0.0300 - val_acc: 0.9904Epoch 9/12 - 249s - loss: 0.0465 - acc: 0.9862 - val_loss: 0.0286 - val_acc: 0.9906Epoch 10/12 - 257s - loss: 0.0423 - acc: 0.9866 - val_loss: 0.0261 - val_acc: 0.9910Epoch 11/12 - 243s - loss: 0.0393 - acc: 0.9883 - val_loss: 0.0313 - val_acc: 0.9903Epoch 12/12 - 277s - loss: 0.0413 - acc: 0.9877 - val_loss: 0.0266 - val_acc: 0.9907Test loss: 0.026646837043244158Test Accuracy: 0.9907Process finished with exit code 0 如果是第一次运行，会从 https://s3.amazonaws.com/img-datasets/mnist.npz 下载数据集，Windows会存放在c://Users//&lt;User name&gt;//.keras/datasets下面；Linux会存放在home/.keras/datasets下面。 cifar10_cnn.py12 训练过程 参考 Keras Model API: https://keras.io/models/model/ mnist_cnn.py: https://github.com/keras-team/keras/blob/master/examples/mnist_cnn.py cifar10_cnn.py: https://github.com/keras-team/keras/blob/master/examples/cifar10_cnn.py https://www.cnblogs.com/lfri/p/10485597.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[李学龙老师在2017届本科生毕业典礼上的讲话]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%9D%8E%E5%AD%A6%E9%BE%99%E8%80%81%E5%B8%88%E5%9C%A82017%E5%B1%8A%E6%9C%AC%E7%A7%91%E7%94%9F%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[演讲原文尊敬的各位老师、各位家长，各位师弟、师妹们： 大家早上好！ 我想汇报和分享的很多故事其实都是“曾经”，但是我今天更想用“这一年”来说。曾经有一首歌叫《同桌的你》，曾经有一部电影叫《大话西游》，曾经有一本书叫《未来之路》，曾经在这一年我到了合肥。大约坐了将近40个小时的火车，其实完全可以加上一个注释：怀抱着光荣、梦想、期望、憧憬，但其实对我来说，当时旅途就是旅途本身，至多是一种坚持，至少当时我是这么认为的。在这一年，在北方长大的我，第一次见到了竹子，它顽强地在并不富饶的土地上茁壮成长；在这一年很多来自南方的同学，他们第一次见到了水在极端情况下的迸发和绽放。1994年的漫天大雪里，我现在还能记得很多穿着单衣的同学在欢呼雀跃。 这一年，我18岁之前建立的所有自信心都被打碎了，荡然无存，如樯橹灰飞烟灭，因为在我曾经自诩很擅长的每一个方面都有N多的人比我强。当我跟他们一样穿着拖鞋、端着饭盆去食堂的时候，总会有人说“看！这是国奥金牌，这也是国奥金牌，这是某个省的状元，这又是某个省的状元。”其实给人压力最大的并不是你知道有人比你优秀，而是你每天都要和他们在一起；也不是说你觉得比你优秀的人比你更努力，而是你发现其实他们不太努力的时候还是比你优秀。在这一年，很幸运的，我跟他们一样有了一个让我终生引以为傲、倍加珍惜的名字——科大人！ 科大人很拼，江湖传言“穷清华，富北大，不要命的上科大”。但科大就是科大，科大有自己的秉持、自己的传统、自己的文化、自己的理念，我们其实没有必要去跟别人去比。科大人很萌，像“天使路”、“勤奋路”这样的名字，如果不是情商和智商的终极极品爆发大概是想不到的。科大人很执着，1995年毕建忠（9304/9315校友）和我分别任校学生会东西区体育部长的时候，我们（重新）启动了“巾帼杯”女子足球赛，听说一直踢了二十几年，到现在还有。科大人很团结，这个不需要多说，等大家到新的学习和工作岗位上，大家自然会知道，我保证。其实科大人还有很多共同的禀赋和标签，刚才蒋书记和校长也都提到了，像“红专并进，理实交融”其实已经融进了科大人的血脉，已经刻入了科大人立德树人的骨髓。 我是早上三点半的航班到的合肥，我当时在想跟大家讲点什么呢？其实我想了讲“知道，不知道，知不道，道不知”的故事，或者给大家讲“知足，不知足，知不足”的故事。后来想了想，还是不讲这些了。因为我的资历和经历也比较有限，很多故事也是听别人讲的。所以在毕业典礼的时候，我想给大家讲两个我会对毕业生说的我的担心吧。 首先，我担心大家会以为社会上和大学里是一样的。其实我们看一下大学，从中国古代的太学到西方古典模式的大学到中西方现代模式的大学，大学始终是这么一个存在，它鼓励我们去弘扬我们的品德、砥砺我们的品格、开拓我们的视野、激发我们的潜力，让我们不断地完善和更新，达到一种更好的自我，趋于完美和完善的境地。虽然大学的入门门槛在不断地调整，但大学始终是一个象牙塔，它是社会少数精英阶层的消费。但是当我们迈向社会的时候，我们会发现，盖人生历程，大抵逆境居十之六七，顺境亦居十之三四，而顺逆两境又常相间，我们会碰到很多的困难。为什么呢？因为社会对年轻人的宽容和忍让、理解和支持同大学是不一样的。“物可瞬间无主，人须时时有心”，我们能保证不变初心，在我们的追求和志向不被外物所改变的情况下，我建议大家学会适应。达尔文在《物种起源》里说，得以生存的不见得是最强大的，也不见得是最智慧的，但一定是最适合环境的。唯一不变的事情就是变化本身，所以我送给大家的第一个词是“适应”，并请大家记住，适应绝不是随波逐流。 第二个担心是，我担心大家认为课本里学到的知识可以让大家出去生活，至少是生存了，因为生活和生存是两个概念。其实课本里的知识如果是完备的话，我们没有必要去建立一所实体大学。事实上课本里的知识、大家学过的知识很可能是不完备的，不齐整的，甚至可能是不正确的。以光学为例，我有两个透镜，有一个光轴，这边有个蜡烛，这边有个屏，蜡烛成什么样的像，这个我们可以在课本中学到，但是你在做一个实际系统的时候，这两个透镜能严格地同轴吗？或许不能！这个时候该怎么解决，课本里似乎不会告诉你。那么学电的话，我们学电子管、晶体管，并不表示我们要去用它，我们是要知道历史上发生过什么样的事情，我们应该怎么样去学习，我们要学习“学习的本领”，我们去归纳总结，去提炼升华。其实，科学研究本身至少有两个目的。第一个目的是实际的应用，去解决实际的问题。我们理工科的学生，尤其应该如此，绝对不能纸上谈兵。那么另一个目的就是满足人类对世界的好奇心。我们知道在电口（电学）上很著名的故事。当法拉第发现电磁感应定律的时候，他并不知道能做什么；麦克斯韦预言电磁波存在的时候，法拉第刚刚去世；当赫兹证明电磁波存在的时候，麦克斯韦又刚刚去世；当马可尼开始进行无线通讯的时候，赫兹也去世了。但是我们不能忘记科学史上这一步一步好奇心的驱使。其实能够鼓励创新的年代并不是特别的多，我们常说“千里马常有，而伯乐不常有”。我们看一看在欧洲，从后希腊到罗马到文艺复兴，其实创新沉睡了一千年。在中国我们有卷帙浩繁的经史子集，我们几乎可以从中间找到现在的任何一个发现或发明的原始的雏形，但是我们必须要承认，我们的技术是多于科学的，我们没有能够把炼丹术发展成化学，没有能够把观星术发展成天文学。所以在今天，在全国、全社会鼓励创新驱动发展的时候，我想大家还是非常幸运的。所以我想送给大家第二个词是“好奇”，而且好奇绝不是随心所欲。 我个人并不是特别推崇“人情练达即文章”，但是我坚信“世事洞明皆学问”。我想在大学的五年里（现在是四年制），大家至少学会了一个人的时候怎么样去平静、去思考，两个人的时候怎么样去合作、去争论，三个人的时候如何去协调、去平衡。其实我们担心的事情还很多，我们担心大家有成绩的时候妄自尊大，担心大家碰到困难的时候妄自菲薄。正因为大家很优秀，所以我们的担心才很多。 15年前的毕业典礼，我是博士生的毕业代表，到现在我还记得当时我的发言，我说“春来几度，苍翠依旧，于无声处，却已见茁壮。而今我们将成为科大的历史，但母校永远是我们心中的一座丰碑，上面镌刻着老师的关爱、同学的友情，和我们的点点滴滴……”很快大家就要离开这个校园，可能还会离开这个城市，或许很多人可能还会短期或长期离开我们的祖国，但是我深信大家或早或晚一定会回来！我是毕业6年之后回到合肥，我没有去会场，我直接打车到了黄山路的一个小饭店，进去之后，老板一句不经意的问候“很久没见了”，让我“泪飞顿作倾盆雨”，刚才在我们的校旗传过来的过程中，我心里就是这样的感觉。 我想大家一定会记得这一年，虽然这一年以后也会成为曾经，但是大家一定会记得在这一年大家收获了母校、老师、师兄师姐们的一些不可辜负的爱和期望。如果每一位科大人都是一颗闪亮的星，那么我们希望以一颗颗星的光芒去引领整个星河璀璨、瀚海星云的梦想。谢谢大家！ 演讲视频 李学龙(946)校友在2017届本科生毕业典礼上的讲话(节选)]]></content>
      <tags>
        <tag>李学龙</tag>
        <tag>演讲</tag>
        <tag>科大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛祖.py]]></title>
    <url>%2F2019%2F05%2F04%2F%E4%BD%9B%E7%A5%96-py%2F</url>
    <content type="text"><![CDATA[皮一下哈哈… 代码123456789101112131415161718192021222324252627282930print(" _ooOoo_ ")print(" o8888888o ")print(" 88 . 88 ")print(" (| -_- |) ")print(" O\\ = /O ")print(" ____/`---'\\____ ")print(" . ' \\| |// `. ")print(" / \\||| : |||// \\ ")print(" / _||||| -:- |||||- \\ ")print(" | | \\\\\\ - /// | | ")print(" | \\_| ''\\---/'' | | ")print(" \\ .-\\__ `-` ___/-. / ")print(" ___`. .' /--.--\\ `. . __ ")print(" ."" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'"". ")print(" | | : `- \\`.;`\\ _ /`;.`/ - ` : | | ")print(" \\ \\ `-. \\_ __\\ /__ _/ .-` / / ")print(" ======`-.____`-.___\\_____/___.-`____.-'====== ")print(" `=---=' ")print(" ")print(" ............................................. ")print(" 佛祖镇楼 BUG辟易 ")print(" 佛曰: ")print(" 写字楼里写字间，写字间里程序员； ")print(" 程序人员写程序，又拿程序换酒钱。 ")print(" 酒醒只在网上坐，酒醉还来网下眠； ")print(" 酒醉酒醒日复日，网上网下年复年。 ")print(" 但愿老死电脑间，不愿鞠躬老板前； ")print(" 奔驰宝马贵者趣，公交自行程序员。 ")print(" 别人笑我忒疯癫，我笑自己命太贱； ")print(" 不见满街漂亮妹，哪个归得程序员？") 打印效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[写出pythonic的代码]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%86%99%E5%87%BApythonic%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[列表遍历Pythonic1234names = ['juntao', 'xiaojun', 'mingming', 'haohao']# 查找名字列表中带有字母'm'的名字m_name = [name for name in names if 'm' in name]print(m_name) 不要用循环写！12345m_name = []for name in names: if 'm' in name: m_name.append(name)print(m_name) 字典遍历Pythonic1234exam_detail = &#123;'juntao': 44, 'xiaojun': 88, 'mingming': 99, 'haohao': 22&#125;# 找出及格的学生及其分数score_greater_than_60 = &#123;k: v for k, v in exam_detail.items() if v &gt;= 60&#125;print(score_greater_than_60) 不要这样写！12345score_greater_than_60 = &#123;&#125;for k, v in exam_detail.items(): if v &gt;= 60: score_greater_than_60[k] = vprint(score_greater_than_60) 参考文章 一些 pythonic 的代码实例：https://github.com/mikeckennedy/write-pythonic-code-demos https://blog.csdn.net/g8433373/article/details/80709116]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些Python语法]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%80%E4%BA%9BPython%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关键字 globalglobal关键字主要目的是为了在函数中使用全局变量。1234567891011121314count = 10def modify_count(): temp_count = 20 print('local variable: ', temp_count) global count print('global variable: ', count) count = 100 print('after modified: ', count) returnprint('before modify_count(): ', count)modify_count()print('after modify_count(): ', count) 输入结果：1234567before modify_count(): 10local variable: 20global variable: 10after modified: 100after modify_count(): 100Process finished with exit code 0 从代码中可以看到，，如果要在函数modify_count()中使用全局变量count，那么需要使用global关键字修饰。同时，函数内部对count的修改，将影响到函数外面count的值。 if __name__ == &#39;__main__&#39; 说明因为在 Python 中，一个.py文件就是一个模块，模块中一般写了很多函数供其他模块使用。但我们需要测试模块中函数的正确性，这时候就需要用到 if __name__ == &#39;__main__&#39;. __name__是每个模块的一个属性名，如果我们需要在当前模块中编写测试代码，一般情况下，我们是将测试代码放在 if __name__ == &#39;__main__&#39;这条判断语句下面，因为如果是直接运行当前模块，那么__name__的值就是__main__，条件判断下面的测试代码将会被执行。 如果有另外一个模块module_2.py引用了当前模块module_1.py,那么当我们运行module_2.py时，module_1.py中的__name__的值将变成module_2，即引用了module_1这个模块的模块名。那这时module_1中的if判断将不满足，也就不会执行测试代码，module_2也就只是导入了module_1中的函数，符合我们的期望。 np.random.seed()说明seed(int) 接收一个整数做为生成随机数的算法的参数。如果接收到的整数值相同，那么产生的随机数也相同。 代码123456import numpy as npnum = 0while num &lt; 5: np.random.seed(5) print(np.random.random()) num += 1 输出结果123450.221993171089739480.221993171089739480.221993171089739480.221993171089739480.22199317108973948 但是设置的seed()的值只生效一次，下次使用random()函数如果不是上次的seed()值，那么将会产生不同的随机数。 代码123456import numpy as npnum = 0np.random.seed(5)while num &lt; 5: print(np.random.random()) num += 1 输出结果123450.221993171089739480.87073230617737640.206719155339426420.91861090793792160.48841118879482914 从结果可以看到，第一次输出的random()值，由于和上面代码一样设置了seed(5)，所以第一行结果相同；但是后面4次循环由于没有继续设置seed()，因而产生的随机数不同。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm在需要输入命令行参数时如何调试]]></title>
    <url>%2F2019%2F04%2F30%2Fpycharm%E5%9C%A8%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%97%B6%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1. 前言在 pycharm 中进行调试，一般的做法是：先设置断点，然后开始调试程序。调试过程中选择step over, step into, step out, resume program等操作。 但是当程序需要从命令行中读取参数时，该怎么调试呢？ 如果和之前一样，设置断点，然后开始调试，但在这种做法下，程序没有从命令行中获取到参数；如果在 pycharm 的 teminal中输入 python xxx.py -x xx -y yy -z zz，这种做法会直接运行完程序，无法在断点处停下来。 2. 解决方法在 pycharm 中选择 Run -&gt; edit configurations，然后在parameters中填入需要设置的命令行参数，这时候不需要输入python xxx.py。点击apply然后OK。 然后在代码中就可以直接 debug 了，会在断点处停下来。 参考文章 https://blog.csdn.net/wishchin/article/details/78560725]]></content>
  </entry>
  <entry>
    <title><![CDATA[pycharm调试]]></title>
    <url>%2F2019%2F04%2F29%2Fpycharm%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[pycharm中调试功能按钮说明列表 竖排 Resume Program(F9): 运行到下一个断点。 横排 step into(F7)和step into my code(Shift+Alt+F7之间的区别：前者会进入到一些系统函数内容，后者只会进入自己定义的函数内部。 参考文章 pycharm调试功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下使用virtualenv新建一个python3虚拟环境]]></title>
    <url>%2F2019%2F04%2F28%2Fubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8virtualenv%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AApython3%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 虚拟环境的意义因为不同的应用需要的环境可能是不同的，比方说A和B程序都需要用到第三方库C，但是A只能在C(version=1.0)下面运行，B只能在C(version=2.0)下面运行，这时要想同时运行A和B程序就会存在问题。 虚拟环境提供的好处就是，可以将不同应用程序所需要的环境隔离开来，每个程序有一套属于自己专属的环境，程序之间不会相互干扰。 2. 步骤 首先需要安装 virtualenv 1sudo apt-get install python-virtualenv 接着创建 python3 的虚拟环境(ubuntu中默认安装了python2和python3) 1234cd ~/1997tanjuntao/ # 切换到一个目录下面virtualenv -p /usr/bin/python3 py3env # 在当前目录下面创建新目录py3env(目录名可以自定义)，py3env中就是虚拟环境# 如果是新建一个python2环境，可以这样做# virtualenv -p /usr/bin/python2 py2env 接着激活环境 切换到py3env所在目录1cd ~/1997tanjuntao/ source命令激活虚拟环境1source py3env/bin/activate 这时候会发现命令行前面多了一个括号 (py3env) 这个新建的虚拟环境中使用的是python3，默认情况下，没有包含系统python3中安装的包，很干净。 这时候使用pip install安装的第三方包，只存在于这个虚拟环境中，不会影响系统中的python3 退出虚拟环境1deactivate # 一句话 参考文章 https://blog.csdn.net/qingche456/article/details/65465760]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决hexo中发布文章后图片无法显示的问题]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%90%8E%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 问题描述默认情况下，在 hexo 中新建一篇markdown博文，在文章中插入本地图片，再部署到 github 上面，是无法显示这些图片的。 2. 解决方法首先找到博客根目录下面的_config.yml文件，修改post_assrt_folder的值为true. 接着 git bash 切换到博客根目录下面，安装第三方插件hexo-assrt-image1npm install hexo-assrt-image --save 接着hexo new &quot;文章名&quot; 新建一篇文章，会发现source/_posts/目录下面会生成一个和 markdown 文件同名的文件夹。再将当前这篇文章中需要插入的图片放到这个文件夹中，再到 markdown 中引用该文件夹中的图片，最后hexo g -&gt; hexo d，就可以正常的查看这些图片了。 参考文章 https://blog.csdn.net/qq_38148394/article/details/79997971 https://www.jianshu.com/p/3db6a61d3782]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决pycharm在同目录下import，pycharm会报错，但实际可以正常运行的错误]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3pycharm%E5%9C%A8%E5%90%8C%E7%9B%AE%E5%BD%95%E4%B8%8Bimport%EF%BC%8Cpycharm%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1. 问题描述假如我们的目录结构是这样： 项目名称是HelloWorld，在项目主目录下面新建一个文件夹test_dir，接着在HelloWorld/test_dir目录下面新建两个文件: HelloWorld/test_dir/hello1.py和HelloWorld/test_dir/hello2.py。 hello1.py中插入如下代码：1234import hello2 as h2print(h2.hello_world())print(h2.nihao()) hello2.py中插入如下代码：12345def nihao(): return 'nihao'def hello_world(): return 'hello world' 此时，会发现在hello1.py中一直红线提示No module named hello2： 但是如果我们运行hello.py发现是能够正常输出结果的。 2. 解决方法在左侧工程目录树中，选中test_dir，右键，然后选择 Mark directory as，再选择source root，然后就会发现先前的红线错误提示已经没有了。 3. More…如果我们是在当前工程主目录下面新建两个文件HelloWorld/hello1.py和HelloWorld/hello2.py，两个.py文件的代码内容和之前一样，这时候却又不会出现No module named hello2这种错误了。 参考文章 https://www.zhihu.com/question/52880389/answer/134369870]]></content>
  </entry>
  <entry>
    <title><![CDATA[论论文笔记: Manipulating Machine Learning: Poisoning Attacks and Countermeasures for Regression Learning]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%AE%BA%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Manipulating-Machine-Learning-Poisoning-Attacks-and-Countermeasures-for-Regression-Learning%2F</url>
    <content type="text"><![CDATA[这篇文章发表于 2018 年，是第一篇针对线性回归模型提出投毒攻击方法的论文，实验证明：这种gradient-based的攻击方法效果很好；同时这篇文章里面也提出了一种防御方法：TRIM，实验结果也证明其防御效果很好。 主要贡献 第一篇针对linear regression进行poisoning attack的论文，之前的论文都是针对classification的模型 改造了一个原本针对分类问题进行投毒攻击的模型，将其应用在回归问题中，将攻击结果作为一个baseline 提出了一种基于数据集统计特征的攻击方法，只需要掌握有限的信息即可完成攻击 提出了防御算法TRIM,能够抵御众多的攻击，效果比传统的robust statistic好 方法Linear Regression Model传统的线性回归模型：$$\mathcal{L}\left(\mathcal{D}{\mathrm{tr}}, \boldsymbol{\theta}\right)=\underbrace{\frac{1}{n} \sum{i=1}^{n}\left(f\left(\boldsymbol{x}{i}, \boldsymbol{\theta}\right)-y{i}\right)^{2}}{\operatorname{MSE}\left(\mathcal{D}{\text { tr }}, \boldsymbol{\theta}\right)}+\lambda \Omega(\boldsymbol{w})$$ 根据$\Omega(w)$的不同，linear regression 可以分为下面4种 类型 $\Omega(w)$ Ordinary Least Square(OLS) $\Omega(w) = 0$ Ridge $\Omega(\boldsymbol{w})=\frac{1}{2}\ \boldsymbol{w}\ _{2}^{2}$ LASSO $\Omega(\boldsymbol{w}) = \ {w}_1\ $ Elastic-Net Regression $\Omega(w) = \rho\ w_1\ + (1-\rho)\frac{1}{2}\ w_2^2\ $ Adversarial Model这里定义敌手模型。 敌手模型主要是用来对潜在用户进行分析建模，例如：假设攻击者掌握了多少知识、攻击者的目标是什么、攻击者的攻击策略是什么等。具体的可以从下面4个维度来对潜在的攻击者进行建模： 维度 描述 Adversary Goal 一般包含两种:availability attack &amp; integrity attack.前者主要目的是使整个模型的可用性降低，后者主要是使模型在针对特定样本做 inference 时，准确率降低 Adversary Knowledge 一般包含两种：white-box &amp; black-box. 对于前者，假设攻击者知晓：traning data &amp; learning algorithm &amp; loss function &amp; model parameters；对于后者，假设攻击者只知晓：learning algorithm &amp; loss function。但是这篇文章中，作者通过产生替代数据，同样可以得到 model parameters. Adversary Capability 攻击者的能力，一般定义为其能往数据集中插入多少 poisoning samples. $n:original \ samples$, $p :poisoning \ samples$, $N = n + p:\ total \ smaples$, 定义poisoning rate $\alpha = p/n$ Adversary Strategy $\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$ 攻击者的目标主要是优化上面的目标函数：即如何插入 poisoning samples 来使得在 $D’$上的 loss 值最大. 攻击方法攻击者的目标函数：$$\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$$ 注： 目标函数 $W$一般用 validation set 上面的 loss 来表示。loss 越大，表名攻击效果越好。对于 linear regression, loss function = Mean Square Error(MSE) 那么该插入什么样的 poisoning sample 才能使目标函数 $W$ 的值最大呢？ 答案是：考虑梯度，考虑$W$对$D_p$的梯度。有了这个梯度，我们就能使用gradient ascent方法来更新$D_p$，直到最后$W$收敛，我们可以得到最佳的$D_p$. 但是这个优化问题是一个Bi-level问题，即约束条件本身也是一个优化问题，解决这种问题通常情况下是NP-hard.因为$x_c$和$W$并不是显示相关，而是通过$\theta$间接相关，因此作者通过chain rule来计算所需要的梯度 $\nabla_{\boldsymbol{x}_{c}} \mathcal{W}$: $$\nabla_{\boldsymbol{x}{c}} \mathcal{W}=\nabla{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top} \cdot \nabla_{\boldsymbol{\theta}} \mathcal{W}$$ 注：$x_c$表示 poisoning sample 的 features 1. 首先求解公式的第二项 $\nabla_{\theta} \mathcal{W}$ 第二项比较好计算，因为在线性回归问题中，目标函数表示的是在 validation set 上计算到的 loss： $$\mathcal{W}{\mathrm{val}}\left(\mathcal{D}{\mathrm{val}}, \boldsymbol{\theta}\right)=\frac{1}{m} \sum_{j=1}^{m}\left(f\left(\boldsymbol{x}{j}^{\prime}, \boldsymbol{\theta}\right)-y{j}^{\prime}\right)^{2}$$ 对这个函数求对$\theta$的偏导：$$\nabla_{\boldsymbol{\theta}} \mathcal{W}{\mathrm{val}}=\left[ \begin{array}{c}{\nabla{\boldsymbol{w}} \mathcal{W}{\mathrm{val}}} \ {\nabla{b} \mathcal{W}{\mathrm{val}}}\end{array}\right]=\left[ \begin{array}{c}{\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right) \boldsymbol{x}{j}} \ {\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right)}\end{array}\right]$$ 至此，公式第二项偏导数计算完毕，下面计算第一项。 2. 求解公式第二项 $\nabla_{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top}$ 防御方法实验结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH公钥方式登录原理以及对称加密和非对称加密知识点总结]]></title>
    <url>%2F2019%2F04%2F10%2FSSH%E5%85%AC%E9%92%A5%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先占坑，后面需要学习这块的内容，用博客记录下来，加深理解！ 参考文章 https://blog.csdn.net/csm201314/article/details/78453579]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统中常见目录的含义及作用]]></title>
    <url>%2F2019%2F04%2F02%2FLinux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言这篇博客将随着我对 Linux 系统的不断使用和了解而不定期更新。 常用目录的含义 目录 含义 /bin 存放 linux 中常用命令，如cd pwd ls等 /lib /etc /var 参考文章 http://blog.sina.com.cn/s/blog_684d52a90102uw30.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装固态硬盘]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%AE%89%E8%A3%85%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[0.前言以下全是个人的装机经验，没有很认真的写，只是打算做个记录，这样下次如果还需要干这类活时有个参考。不建议follow！！仅供一点参考。 笔记本老早就出现各种问题了，觉得应该是系统的问题而不是硬件的问题，于是寻思着重装一下系统。但是心里对重装系统有些抵触，因为会导致很多之前辛苦安装好配置好的软件无法使用。拖了好久，终于买了一块固态硬盘来重装系统…笔记本简直焕发第二春啊！ 1. 数据备份 为了避免发生意外情况，建议还是首先把原先硬盘中重要的文件备份一下。所谓备份，就是把一些重要的文件拷贝到另外一块存储介质中，如移动硬盘等，这样重装系统能够放心点。 其实需要备份的文件感觉不是很多，个人觉得下面这些需要着重备份： C盘：桌面，图片，视频。偷懒一点，就把user文件夹全部备份一下，因为这个差不多是系统盘中最重要的文件了。 其它：如果是数据盘，那不用考虑，所有的文件都得备份。如果是软件盘，那么之前一些工程文件目录，如eclipse，webstorm，pycharm等，做好备份。另外Tim，微信聊天记录也最好备份一下，这样重装之后可以直接导入这些记录。 2. 制作启动U盘因为打算把新系统装到 SSD 中，所以需要事先制作一个启动 U 盘，用来安装新系统。 下载系统iso镜像 可以使用微软官方的渠道下载，直接搜索windows10镜像下载 微软，然后下载一个工具，让其将Windows操作提供写入到U盘中(U盘会被格式化，事先备份U盘) 也可以使用第三方的镜像，比较推荐的是 MSDN我告诉你。找到打算下载的镜像，将完整的ed2k地址复制到迅雷等下载工具中，启动镜像下载。 制作启动U盘 可以使用UltraISO rufus等启动U盘制作工具，导入之前下载的iso镜像，就可以轻松完成U盘制作。 3. 拆机拆机过程中不用太担心，小心操作，一般不会带来什么问题的。拆机之前记得先把笔记本电源取下来，防止意外发生。 将笔记本后盖中所有看得见的螺丝全部拧下来，然后将笔记本后盖和主板分离。这个过程中需要留意一点，因为主板上面有可能有线和后盖通过一个卡口连在一块，所以在取下后盖之前，需要将这个卡口解开，不能直接就分离后盖。 找到硬盘位。拧下所有的螺丝，将原来的 HDD 取下，装上新的 SSD，按照相反的步骤再装回原位，这样新的固态硬盘就轻松的装好了。 找到光驱位。拧下所有的螺丝，将原来的 HDD 装入光驱位硬盘托架(需花钱额外购买)，记得一定要将 HDD 装到位，也就是一定要保证接线口是完全缝合的，否则可能在装好新系统后，无法读取到这块 HDD 硬盘。 将原来光驱的前挡板取下来，装到这块硬盘托架上，这样能够保证托架装上笔记本后，不会明显的凹下去，因为如果使用硬盘托架厂商送的通用挡板，会导致笔记本装好后没有一体性，因为光驱位那里凹下去了，影响美观。 将后盖装回去(有线的地方先把线接好)，再将所有的螺丝全部拧回去，这样就完成了拆机安装 SSD 的过程。 4. 重装系统到 SSD目标是将新系统装到 SSD 中，原来的 HDD 作为普通的硬盘使用。 具体的，笔记本开机后，不断按f2 f8 delete(不同笔记本不同)进入BIOS。找到boot，选择从U盘启动。 这时候会识别到刚才新装的固态硬盘，会提示是否需要进行分区，因为SSD一般是128G或者256G，感觉没有必要再分区了，整块盘作为一个分区就可以了。然后接下来就是愉悦的安装过程了，这个比较傻瓜，没什么好说的。 5. 可能的问题 新系统中无法使用触控板。可以卸载当前的触控板驱动，然后去笔记本厂商官网，找到当前这款型号笔记本对应的触控板驱动程序，重新安装就可以了。 读取不到光驱位硬盘。可以搜索一下这个问题，一般会提示让下载一个amd xxx controller，然后打开设备管理器，将驱动程序手动更新一下就可以了。 原先的光驱挡板不好拆卸。实在不行就暴力拆卸，装到托架上时，用502胶水粘一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的正则匹配]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[正则表达式由两个部分组成：1/正则表达式主体/修饰符(可选) 其中修饰符主要用到两种： i: ignore 的意思。表示忽略大小写进行匹配。 g: global 的意思。表示匹配整个字符串，否则第一次匹配成功后，不会继续匹配后面的字符串。 常用的特殊字符 特殊字符 含义 * 0个或者 N 个 + 1个或者 N 个 ? 0个或者1个 .等价[^\n\r] 匹配任意字符(除了换行和回车) \ 可以做转义字符也可以和\b等一起使用表示特殊含义 ^ 匹配输入的开始如/^A/匹配一个以字符A开头的字符串 $ 匹配输入的结束如/t$/匹配一个以字符t结尾的字符串 [0-9] 匹配一个数字 \d 同上匹配一个数字 \s 空白字符(空格、制表符、换行符等) \D等价[^0-9] 匹配一个非数字字符 [a-zA-Z] 匹配任何一个大小写字母 \w 匹配一个单字字符(字符、数字、下划线) \W 同上匹配一个非单字字符 [^xyz] 匹配不包含xyz字符的第一个字符 使用正则表达式的常用方法 方法 描述 replace() 查找匹配的字符串，然后用新字符串替代 split() 将原字符串按照正则表达式拆分，将结果存入到一个数组中 使用括号的子字符串匹配 这种情况下，会将匹配的结果存入到一个数组中，也就是会 记忆 匹配得到的结果。 几个例子 eg1 1234var re = /\w+\s/g;var str = "fee fi fo fum";var myarr = str.match(re);console.log(myarr); 输出结果1["fee+空格", "fi+空格", "fo+空格"] eg2(综合性实例) 1234567891011121314151617181920212223// names中不同名字之间有多个空白字符、制表符等不可见字符var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";console.log("===========original string==============\n" + names);var pattern = /\s*;\s*/;var namelist = names.split(pattern);// console.log(namelist);// 将匹配到的结果存起来作为$1和$2var newpattern = /(\w+)\s+(\w+)/;newnamelist = [];for (var i = 0, len = namelist.length; i &lt; len; i++) &#123; // 名字颠倒 newnamelist[i] = namelist[i].replace(newpattern, "$2, $1");&#125;console.log(newnamelist);// 按照字母表排序newnamelist.sort();console.log(newnamelist); 需要注意的就是函数split()和replace()的使用。 如果是带有括号的，那么匹配的结果将存放在$1 $2 … $n中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Office 2016 激活方法]]></title>
    <url>%2F2019%2F04%2F02%2FOffice-2016-%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[激活方法 下载安装激活工具：链接: https://pan.baidu.com/s/1C3KqB4m7dnm9t2uKoDARHw 提取码: 9r4h Windows 10 中可能会提示说下载的文件中包含病毒，导致下载不成功。这时候只需要在Windows defender中找到刚才那条阻止记录，并将其设置为允许，重新下载文件，就可以下载成功了。 接下来执行压缩包里面的.exe文件，安装到最后，Windows defender又提示说检测到病毒xxx不能执行，安装失败之类的，这时候需要在windows安全中心，选择管理设置，然后关闭实时保护，然后以管理员方式运行压缩包里面的.bat文件，再重新安装刚才那个.exe文件，这时候就可以成功安装了，安装完之后再开启实时保护。 启动软件，点击红色按钮，在打开 office 中的账户，发现已经激活成功了，简直神器！ 参考文章 https://blog.csdn.net/weixin_40941966/article/details/80872533]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3: ModuleNotFoundError: No module named 'PIL']]></title>
    <url>%2F2019%2F04%2F02%2FPython3-ModuleNotFoundError-No-module-named-PIL%2F</url>
    <content type="text"><![CDATA[问题使用matplotlib.pyplot模块调用绘图函数时，出现以上错误。 解决方法在控制台中输入如下命令1pip install pillow 即可解决问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Github Pages + Hexo 搭建一个个人博客]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%BD%BF%E7%94%A8-Github-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言其实在很早之前，曾使用 WordPress 搭建过一个个人博客。当时也是满满的激情，想模仿大佬们学着写技术博客。但是后来由于忙着追求GPA，加上自身懒惰自控力不行，博客就基本放弃更新了。 但是现在已经过上了研究生生活，每天有大把的时间可以由自己来支配，同时接触的东西也越来越多：做项目需要实时的学习一些技术和技巧，需要不断总结下来；各种学术报告会，听完之后需要回去再认真揣摩消化，变成自己的东西，这也需要总结下来。虽然之前也零零散散的做了一些笔记，但是组织松散不方便查找，遂考虑重新开通个人博客，将平常生活中的所学所思都记录下来，做技术和科研的积淀，争取能够厚积薄发！ 开始搭建 1. 前期准备 安装node.js：因为hexo是一个基于node.js开发的静态博客框架，其运行必须要有node.js环境支持 安装git：要往 github 提交代码，就必须先在本地安装好 git 客户端 在 github 上面新建一个仓库，名称设为你的github账户名.github.io 上面软件的安装应该没有大问题，去官网下载一路 next 基本就可以了。需要注意的是，如果之前没有用过 git 提交代码到 github，那么第一次安装 git 之后还需要做些 SSH Key 的设置，这里不打算赘述这个步骤。 2. 安装hexo打开 git bash，直接输入下面这条命令：1npm install -g hexo-cli 安装可能需要几分钟，耐心等待，不出意外的话，能够成功安装 hexo 3. 构建本地目录在本地文件系统中，任意找一个目录作为网站文件的存放目录，比如在 D盘 新建一个目录blog，作为网站所有文件存放的根目录。 在 git bash 中进入这个目录12cd d:cd blog/ 下载安装 hexo 博客系统所需要的各种文件1npm install 安装过程可能比较慢，且没有进度条提示。安装完之后，在blog目录下面会产生很多新的目录，简单解释一下几个常用目录和文件的含义及作用 themes：存放所有的博客主题，hexo 默认安装的主题是 landscape source: 存放所有的 markdown 源文件。所有新建的博文(post) 都存放在source/_posts/ 这个目录下面。如果后面新建了其它页面，比如关于，归档，标签等，那么在source目录下面将会新产生about, achieve, tag等目录。 public：这个目录中存放所有的网页文件，html,css, javascirpt等等。简单说，hexo 会将我们编写的 markdown 文件解析成 html 文件，同时配套生成一些 css 样式文件，进而保护 markdown 源文件不被其他人获取。 _config.yml：全局的配置文件，可以配置网站 标题, 子标题 等 4. 启动前面安装步骤顺利完成之后，就可以在本地启动 hexo 了。 1npm server # 或者是 npm s, 效果等价 这时会提示说在localhost:4000端口可以访问刚刚建立的博客，正常情况下，如果4000端口没有被占用的话，那么就可以正常访问到博客，会有一篇默认的Hello World的博文。如果4000端口被占用了，具体的表现就是网站打不开，那么可以尝试更换一个启动端口，具体命令可以自行搜索。 5. 部署到 Github Page在部署到 github page之前，需要在本地修改一些配置。 首先打开_config.yml，搜索deploy字段，修改为如下格式：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tanjuntao/tanjuntao.github.io.git branch: master 其中第二个repo字段的值，需要改为你在 github 上面那个网站项目对应的 SSH 值，也不打算截图介绍这个 SSH 值是怎么获取到的了。需要注意的是每个:后面需要紧跟一个空格，否则会出错！ 接着，在 git bash 中执行下面的命令：1npm install hexo-deployer-git --save 执行这条命令可能会出错，解决办法是 npm + flush刷新一下缓存, 具体的命令记不清楚。 最后就可以 deploy 到远程的 github 上面了。 1hexo deploy # 或者 hexo d, 效果是一样的 这时候，就可以看到 github 仓库里面生成了很多文件，但是找不到 source 文件夹，这就是前面介绍到的，保护了源文件。 要通过github账户名.github.io方式访问网站，还需要在项目仓库中的setting中设置中找到github page，设置一下后，才能够访问到。 6. 使用后面当需要新建一篇博文时，只需要做下面三个步骤，非常方便！1234hexo new &quot;博文标题&quot;hexo generate # hexo ghexo server # hexo s, 启动本地服务，可在本地中预览效果，这步可选hexo deploy # hexo d 7. 修改主题hexo 中默认使用的主题是landscape,但最为流行的一个主题叫next，打算安装next主题的可以接着往下看。 首先切换到博客更目录下面，也就是前面的blog/目录，执行下面命令：1git clone https://github.com/iissnan/hexo-theme-next themes/next 可能需要一段时间才能完成。 接着打开跟目录下面的_config.yml文件，修改theme字段的值为next就可以了。 如果后期打算更换其它主题，只需要修改这个theme的值就可以了，同样非常方便！ next主题默认的样式还是没有符合我的要求：左边有一个导航栏，且有关于 分类 标签 这些选项，我们还需要进一步对主题进行设置。 在/theme/next/目录中找到_config.yml文件，同样是一个设置文件，只不过仅仅是next这个主题的设置文件。 搜索Scheme，修改其值为Pisces或者Gemini，因为只有这两个 scheme 能显示左右侧边栏。 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 接着搜索sidebar，参考下列注释进行设置：12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 其它一些设置，包括头像，新页面，评论系统等，可以参见Hexo的Next主题详细配置 这篇文章，非常详细！ 8.其它关于使用 hexo deploy时，如何附带像git commit那样的message，只需要如下命令即可：1hexo deploy --message &quot;提交的信息内容&quot; 非常方便！ 9.注意事项 不要修改使用hexo new命令生成的文章标题 在编辑hexo new生成的 markdown 文件时，不要动手修改title的值，否则会导致这篇post无法显示在网站上！ 这篇文章就先到这里啦~ 主要参考 https://segmentfault.com/q/1010000007139908 https://www.jianshu.com/p/3a05351a37dc https://www.jianshu.com/p/40e4349a0cc7]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试博文]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[二级标题：测试markdown语法的支持情况 有序列表 有序列表 无序列表 无序列表 这里是引用内容 123import tensorflow as tfimport numpy as npprint('hello world') 这是行内代码，这是加粗，这是斜体]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
