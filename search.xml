<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[论文阅读笔记：DeepFool: a simple and accurate method to fool neural networks]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9ADeepFool-a-simple-and-accurate-method-to-fool-neural-networks%2F</url>
    <content type="text"><![CDATA[寻找对抗样本的过程就是最优化下面的目标函数： 其中k表示分类器，r表示添加的扰动，delta文中表示的含义是分类器在x这个样本点处的robustness，其实就是扰动的L-2 norm。 分类器在整个数据集上的robustness计算公式如下： 从公式中可以看出，如果添加的扰动越小，计算到的ro值就越小，相应的根据文中的定义，分类器的robustness就越好。 本文中的主要贡献： 提出了一种新的计算对抗样本的方法DeepFool 从实验中验证了：新的攻击算法所添加的扰动更小，同时计算对抗样本所消耗的时间更少 实验中说明了：如果使用不恰当的算法（FGSM算法）来验证分类器的鲁棒性，那么很可能会过分的评估分类器的robustness。 攻击算法细节 二元分类 and 线性分类器 这是最简单的一种情况。我们有一个线性分类器，那么可以得到一个超平面将两个类别却分开来。 现在X属于其中一个类别，也就是在直线（或者超平面）的一侧，想要添加扰动使分类器将其分类为另一个类别，那么只需要将X更新到直线（或者超平面）另外一侧就可以了。 现在优化算法的约束条件是最小扰动，那么就只需要找到X到直线（超平面）的最短距离，使X加上这个距离后转换到直线另外一侧，那么就算是找到了对抗样本，同时也就找到了最小的扰动r(投影距离)。 这时候处理起来就很简单了，只需要使用一次距离公式即可： 分类器： 投影距离： 二元分类 and 非线性分类器 现在考虑一种更为普遍的setting。分类器的决策边界是非线性的。 这种情况等价于：寻找X到曲线的最短距离，然后将X加上这个最短距离，即可导致X转移到决策边界的另外一侧，从而被错误分类。 但是直接找这个投影点是不好找的。我们需要用到一种迭代的算法。下面简单描叙一下如何寻找一个点到一个曲线（或者是高维空间中的曲面）的最短距离。 12345678假设当前是第 i 次迭代我们在Xi这点对分类器使用一阶泰勒展开，我们将会得到一条直线（或者一个超平面）将Xi投影到这条直线上，我们找到了下一次迭代的X(i+1)，同时我们将这次迭代添加的扰动向量记为ri接着我们再在X(i+1)这点使用同样的方法，寻找下一次迭代的点X(i+2)，同时计算r(i+1)我们的算法一直迭代，知道找到的X落在分类器的决策边界上，算法终止。输出：将每一次迭代过程中产生的ri（是一个向量）全部累计起来（向量加法），得到最终的扰动r。 注：最后找到的扰动只能保证我们能将X改变到决策边界上，所以我们还需要在r的基础上乘上一个微小的系数，保证能越过决策边界。 多元分类 and 线性分类器 现在考虑多元分类情况下如何产生对抗样本，首先还是从简单的线性分类器开始考虑。 多元分类情形下，W是一个矩阵，每一行对应着其中一个类别的权重，通过W * X + b，我们最后得到的是一个score value，是一个向量，其中每一维代表每一个类别的评分。最后分类的标准就是找评分值最大的那个类别。所以我们寻找对抗样本，只需要找到一个类别k，使这个类别的评分值比X原来类别的评分值高，那么就可以达到对抗样本攻击的目的。 形式化的描述： 现在我们定义另外一个函数 因为每一个F_k(x)都是线性的，所以这个函数也是线性的，所以存在一个超平面。超平面的一侧函数值大于0，另外一侧小于0. 所以我们只需要添加扰动使这个函数值符号改变，那么我们就找到了一种产生对抗样本的方法。 因为假如现在的样本点X0（正确类别是4，这样说明了上面公式被减掉的那一项是F4(x))，带到函数中值小于0，表面当前类别4的评分值大于第k类的评分值。但是如果现在上述函数的函数值变为正号，说明第k类的评分值大于第4类，所以分类器这时候已经错误分类为第k类了，那么添加的扰动就是X0到这个函数的超平面的投影距离。 但是这个距离可能不是最小的，所以我们需要遍历所有类别k，找到最小的那个投影距离作为最后的扰动距离。 寻找这个类别k的公式 最后的最小扰动公式 多元分类 and 非线性分类器 同前面二元分类问题相似，我们使用的仍然是一阶泰勒展开的思路。 前面的公式是F_k(x) - F_4(x) = 0，现在这两个函数都是非线性函数，我们在Xi这点分别使用一阶泰勒展开，可以得到下面公式： 这个公式表示的是被分类器分类为正确类别的空间。我们找投影点的思路和前面二元分类相似，也是一个不断迭代的过程。 123我们在迭代的每一步都会使用一阶泰勒展开，将非线性的函数转为线性函数然后将Xi投影到这个线性函数所决定的超平面上，得到X(i+1)，同时计算投影距离r(i)然后不断这样一个泰勒展开-&gt;投影-&gt;泰勒展开-&gt;投影的过程，知道最后上述公式的函数值符号发生变化 当然，为了找到最小的扰动，我们需要针对所有的类别，都运用上面的算法，最后取扰动最小的那个。 实验结果 从图中可以看出 DeepFool所添加的扰动较[4][FGSM]和[18][L-BFGS]都要小（ro值越小，表明添加的扰动越小，参见ro的定义函数） DeepFool产生对抗样本的时间很短 上图是模型多迭代训练5个epoch，模型的鲁棒性的变化情况，可以看出： 如果使用原来的干净样本，模型鲁棒性基本没有变化 如果使用DeepFool产生的对抗样本（后5个epoch都是在这对抗样本上训练的），那么模型在1个epoch后的鲁棒性就大大提升 使用FGSM产生的对抗样本做训练，模型的鲁棒性反而会下降！！！ 然后作者们对这个奇怪的现象又做了另外一个实验。 他们将Deepfool产生的扰动放大，然后再使模型在这个放大的样本上训练，看训练后模型的鲁棒性怎么变化，结果如下图 如果只是deepfool产生的对抗样本，那么可以增加模型的鲁棒性；但是如果这个扰动太大了，反而会使模型鲁棒性降低，这就说明了FGSM算法产生的扰动很大，不是最小的扰动 然后作者们还做了一个实验，说明使用正确的方法（扰动更小的攻击方法）更能说明模型的鲁棒性，而使用那些扰动大的方法来评估模型的鲁棒性，往往会过分评估 作者首先是使用FGSM产生对抗样本，然后在这个样本上多训练了5个epoch。接着使用Deepfool在新的模型（更加的鲁棒）上产生对抗样本，计算ro的值，如蓝线所示；同时使用FGSM再重新生成对抗样本，同样也计算ro值，如红色点线所示。可以看到，后者明显过分估计了模型的鲁棒性，实际上行模型并没有其估计的那么鲁棒。]]></content>
  </entry>
  <entry>
    <title><![CDATA[论文阅读笔记：Explaining and Harnessing Adversarial Examples]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AExplaining-and-Harnessing-Adversarial-Examples%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[论文阅读笔记：Intriguing Properties of Neural Network]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AIntriguing-Properties-of-Neural-Network%2F</url>
    <content type="text"><![CDATA[对抗样本（adversarial examples）的开山之作。 文中主要提到了神经网络两个比较奇怪的性质： 神经网络中携带语义信息的不是某单个神经元，而是整个网络所表示的空间。 给样本添加一些轻微的扰动，会导致神经网络模型错误分类，这些样本就称为对抗样本。 这里对第一个性质做简单的说明。 首先，作者们通过观察某个隐层中某个特定神经元对什么样的输入图片会产生最大的激活值，以此来确定这个神经元对什么样的特征是最敏感的，从而确定这个神经元包含什么样的语义信息。这个想法是可行的并且前面（2014年之前）已经有这方面的研究了。实验结果就发现：单个神经元确实能够表示某种语义信息。接着作者们又做了另外一个实验：选择隐层所表示的空间中的一个随机方向（就是基向量的随机线性组合，是隐层中单个神经元所无法表示的方向），然后用同样的方法使其激活值最大。实验结果发现，同单个神经元一样，这个随机的方向也能表示某种确切的语义信息，从而说明了这个随机方向也可以表示某种特征。 所以最后得到的结论就是：神经网络某个隐藏层中携带语义信息的并不是单个神经元，而是这个隐层所表示的整个空间。 文中提出来的几个假设： it is assumend that is possible for the output unit to assign non-significant(and, presumaby, non-epsilon)probabilities to regions of the input space that contain no training examples in their vicinity. the adversarial examples represent low-probability(high-dimensional)”pockets” in the manifold, which are hard to efficiently find by simply randomly sampling the input around a given example. 那么作者们是如何找到对抗样本的呢？ 寻找对抗样本的过程，其实是一个不断优化的过程：一方面我们希望添加的扰动尽可能小，因为如果是较大的扰动，任何state-of-the-art的模型都会错误分类，就算是人眼也可能识别不了，这和对抗样本问题的研究初衷不一样，我们想知道的是为什么神经网络在面对这些人眼不可分辨的图片时，会给出巨大的错误结果。另一方面，我们希望对抗样本能被错误分类到另一个其它类别，从损失函数的角度看，就是想让其越大越好，于是作者们给出了下面的优化目标函数： 其中x是原始图片，r是添加的扰动，f是分类器，l是目标类别（同x正确的类别不同）。我们希望r越小越好，同时使对抗样本x + r被错误分类到一个指定类别l下，同时还需要生成的x + r的值在[0,1]之间（保证是一张合法的图片）。 直接解这个问题不容易，因此作者转换了一种思路，从损失函数的角度找最优的r: 简单看看损失函数：一方面我们需要r的某种范式越小越好，另一方面我们希望loss(x+r, l)越小越好，因为这样表明x+r分类成类别l的概率越大。所以我们的目标是最小化上述公式，用到的方法是box-constrained L-BFGS. 最后，作者们通过实验发现了几个重要的现象： 对于论文中提到的所有网络结构（non-convolutional network, AlexNet, QuocNet），都能用上述方法生成对抗样本； 对抗样本具有跨模型的泛化能力：在A模型上产生的对抗样本，有很大一部分在B模型（和A模型结构相同，超参数不同）上也有效（也能是B模型错误分类） 对抗样本具有跨数据集的泛化能力：在D1数据集训练得到的模型上产生的对抗样本，在D2数据集训练得到的模型上也有效，D1和D2属于不同的子集，两个模型是结构完全不同的模型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法：感知机]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%9A%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[注：代码和运行结果都是从jupyter notebook中导出的 导入所需要的第三方库12345import pandas as pdimport numpy as npfrom sklearn.datasets import load_irisimport matplotlib.pyplot as plt%matplotlib inline 导入数据（iris数据集是sklearn中自带的数据集）123456# load datairis = load_iris()df = pd.DataFrame(iris.data, columns=iris.feature_names)df['label'] = iris.targetdf.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label']df.label.value_counts() 2 50 1 50 0 50 Name: label, dtype: int64 选取两个特征sepal length和sepal width，绘制散点图12345plt.scatter(df[:50]['sepal length'], df[:50]['sepal width'], label='0')plt.scatter(df[50:100]['sepal length'], df[50:100]['sepal width'], label='1')plt.xlabel('sepal length')plt.ylabel('sepal width')plt.legend() &lt;matplotlib.legend.Legend at 0x1b17e936160&gt; 数据处理：将pandas类型数据转换为np.array123data = np.array(df.iloc[:100, [0, 1, -1]])X, y = data[:, :-1], data[:, -1]y = np.array([1 if i == 1. else -1 for i in y]) 定义模型12345678910111213141516171819class Model(): def __init__(self): self.w = np.ones(len(data[0])-1, dtype=np.float32) self.b = 0 self.l_rate = 0.1 def linear_func(self, w, b, x): return np.dot(x, w) + b def fit(self, X_train, y_train): finished = False while not finished: wrong_count = 0 for d in range(len(X_train)): if y_train[d] * self.linear_func(self.w, self.b, X_train[d]) &lt;= 0: self.w = self.w + self.l_rate * y_train[d] * X_train[d] self.b = self.b + self.l_rate * y_train[d] wrong_count += 1 if wrong_count == 0: finished = True return "perceptron model" 1234perceptron = Model()perceptron.fit(X, y)print(perceptron.w)print(perceptron.b) [ 7.8 -10. ] -12.099999999999973 使用自己训练的模型做二分类1234567x_points = np.linspace(4, 7, 10)y_ = -(perceptron.w[0] * x_points + perceptron.b) / perceptron.w[1]plt.plot(x_points, y_)plt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='0')plt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='1')plt.legend() &lt;matplotlib.legend.Legend at 0x1b17ecb4d68&gt; 使用sklearn中自带的感知机模型123456from sklearn.linear_model import Perceptronclf = Perceptron(fit_intercept=False, max_iter=1000, shuffle=False)clf.fit(X, y)print(clf.coef_)print(clf.intercept_) [[ 74.6 -127.2]] [0.] c:\python36\lib\site-packages\sklearn\linear_model\stochastic_gradient.py:183: FutureWarning: max_iter and tol parameters have been added in Perceptron in 0.19. If max_iter is set but tol is left unset, the default value for tol in 0.19 and 0.20 will be None (which is equivalent to -infinity, so it has no effect) but will change in 0.21 to 1e-3. Specify tol to silence this warning. FutureWarning) 绘制sklearn训练得到的感知机模型1234567x_points = np.arange(4, 8)y_ = -(clf.coef_[0][0] * x_points + clf.intercept_) / clf.coef_[0][1]plt.plot(x_points, y_)plt.plot(data[:50, 0], data[:50, 1], 'bo', color='blue', label='0')plt.plot(data[50:100, 0], data[50:100, 1], 'bo', color='orange', label='1')plt.legend() &lt;matplotlib.legend.Legend at 0x1b17f046278&gt; C:\Python36\Lib\site-packages\sklearn\datasets\data]]></content>
  </entry>
  <entry>
    <title><![CDATA[python中如何批量修改文件后缀名]]></title>
    <url>%2F2019%2F07%2F05%2Fpython%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D%2F</url>
    <content type="text"><![CDATA[需求背景win10中的锁屏壁纸着实好看，想着能不能在本机中找到壁纸存放的目录，于是网上搜了一下，还真有。 壁纸文件存放的目录是1C:\Users\18856\AppData\Local\Packages\MicrosoftWindowsContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets 上面18856是我电脑上的账户名，只需要修改为你自己的账户名即可，其它的所有分级目录都相同。 切换到噶目录下后，发现所有文件都没有后缀名，不能直接用图片查看器打开，需要一个个修改后缀名为.jpg格式，但是手工是在是太麻烦，因此想着用Python批量修改。 实现用os.path里面几个常用的API可以实现需求。 代码123456789101112131415161718192021222324import osimport syspath_input = sys.argv[1]ext_input = sys.argv[2]components = path_input.split('\\')path_new = ''# 将原始单斜杠'\'转为双斜杠'\\'for idx, item in enumerate(components): if idx != (len(components) - 1): path_new += item + '\\\\' else: path_new += item# print(path_new)files = os.listdir(path_new)for file in files: # 分隔文件名和后缀名 fullname = os.path.splitext(file) newname = fullname[0] + ext_input os.rename(path_new + '\\\\' + file, path_new + '\\\\' + newname) 运行从命令行中运行，需要附带两个参数： 原文件所在的目录，将windows中文件资源管理器上的路径拷贝过来； 目标后缀名，如.jpg 运行示例12python batch_rename.py C:\Users\18856\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets .jpg 参考文章 https://www.runoob.com/python/att-string-split.html https://www.cnblogs.com/wuxie1989/p/5623435.html https://blog.csdn.net/weixin_40449300/article/details/83184928]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装jupyter notebook和修改字体]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%89%E8%A3%85jupyter-notebook%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[安装 jupyter notebookjupyter notebook 有两种方式安装：一种是通过 Anaconda，Anaconda里面已经集成了jupyter notebook；另一种是通过pip install安装，本文中我采用的是第二种安装方法。 我Windows系统中只安装了Python3，因此控制台中输入python就指向Python3，如果系统中Python2和Python3共存，那么在控制台中可能需要输入python3，因为官方建议在Python3下面安装jupyter notebook。 在控制台中输入下面命令安装jupyter notebook:12python -m pip install --upgrade pippython -m pip install jupyter 安装需要花一定时间，等成功之后，在控制台输入:1jupyter notebook 启动jupyter notebook。然后选择一个目录，点击new就可以新建Python文件了。 配置 jupyter notebook 主题和字体这里首先需要安装一个第三方包jupyter-themes:1pip install jupyterthemes github仓库中有每个参数（包括主题、字体、字体大小等）的详细介绍和如何配置，如果有需要可以耐心研究研究。 下面这个配置可以比较好的满足需求。1jt -t oceans16 -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T 直接在控制台中输入上述命令，接着重新启动jupyter notebook就可以更新设置了。 最后的效果是这样的： 参考文章 https://blog.csdn.net/qq_30565883/article/details/79444750 https://jupyter.org/install.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何删除github仓库中某个文件或者文件夹]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4github%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[从远处clone仓库到本地在本地任意找一个文件夹，鼠标右键打开git bash，将远程仓库clone到此文件夹下面。1git clone &lt;仓库的git地址&gt; 进入到仓库目录中1cd &lt;仓库名&gt; 删除文件夹如果文件夹名称是单独的英文单词，不带有空格，那么输入：1git rm -r &lt;文件夹名&gt; 如果文件夹名称是中文名或者带有多个英文单词但是使用空格分隔，那么输入1git rm -r &apos;&lt;文件夹名&gt;&apos; # 同前面的区别是多了单引号，可以使用tab补全文件夹名称 删除文件如果只是删除某个特定文件的话：1git rm &lt;文件名全程&gt; # 包含文件名+后缀 如果需要批量删除某类后缀名的文件1git rm *.&lt;后缀名&gt; # e.g. git rm *.md 将修改提交到远程仓库123git add *git commit -m &quot;输入提示信息&quot;git push origin master 搞定！]]></content>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld of Keras]]></title>
    <url>%2F2019%2F05%2F17%2FHelloWorld-of-Keras%2F</url>
    <content type="text"><![CDATA[mnist_cnn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf8 -*-# "Hello World" of Keras in image classification taskfrom __future__ import print_function # 在Python2的代码中可以使用Python3的print函数，即需要加上括号import kerasfrom keras.datasets import mnistfrom keras.models import Sequential # 序列模型，可以封装各种网络层: 卷积层、池化层、全连接层、dropout等from keras.layers import Dense, Dropout, Flattenfrom keras.layers import Conv2D, MaxPooling2Dfrom keras import backend as K # Keras是一个高层API，后端使用TensorFlow或者Theanobatch_size = 128num_classes = 10epochs = 12 # 12个epoch足够训练好模型img_rows, img_cols = 28, 28 # mnist dataset中image的大小# 如果第一次跑，会通过url方式从amazon下载mnist.npz；如果已经下载过了，那么直接加载本地mnist.npz(x_train, y_train), (x_test, y_test) = mnist.load_data()# 根据不同的后端，将图片转换为不同的格式，TensorFlow是channel_lastif K.image_data_format() == 'channels_first': x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols) # 通道为1 x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols) input_shape = (1, img_rows, img_cols)else: x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1) x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1) input_shape = (img_rows, img_cols, 1)# 将每个pixel的类型从integer转为float32，使计算更加精确x_train = x_train.astype('float32')x_test = x_test.astype('float32')# 将0-255范围的pixel值转化到0-1x_train /= 255x_test /= 255# 如果后端是TensorFlowprint('x_train shape:', x_train.shape) # 输出(60000, 28, 28, 1)print(x_train.shape[0], 'train samples') # 输出60000print(x_test.shape[0], 'test samples') # 输出10000# 每个y_train或者y_test本来是一个整数表示每一类，现转换为one-hot encodingy_train = keras.utils.to_categorical(y_train, num_classes)y_test = keras.utils.to_categorical(y_test, num_classes)# 实例化一个序列模型model = Sequential()# Conv1model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=input_shape))# Conv2model.add(Conv2D(64, (3, 3), activation='relu'))# Pool1model.add(MaxPooling2D(pool_size=(2, 2)))model.add(Dropout(0.5))# 将maxpooling后的64个activation map 全部拉伸为一个向量model.add(Flatten())model.add(Dense(128, activation='relu'))model.add(Dropout(0.5))# 用softmax函数将logits转为每个类别的概率model.add(Dense(10, activation='softmax'))# 设置损失函数，优化器，度量标准model.compile(loss=keras.losses.categorical_crossentropy, optimizer=keras.optimizers.Adadelta(), metrics=['accuracy'])# 训练模型# verbose=1 展示详细的训练过程# verbose=0 只显示最后结果，不展示过程# verbose=2 每个epoch输出一条信息，不展示详细的训练过程# validation_data会在每个每个epoch结束后计算当前模型的准确率，validation_data不参与训练model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=2, validation_data=(x_test, y_test))# 在测试集上测试模型效果score = model.evaluate(x_test, y_test, verbose=0)print('Test loss:', score[0])print('Test Accuracy:', score[1]) 训练过程123456789101112131415161718192021222324252627282930313233x_train shape: (60000, 28, 28, 1)60000 train samples10000 test samplesTrain on 60000 samples, validate on 10000 samplesEpoch 1/12 - 248s - loss: 0.2778 - acc: 0.9140 - val_loss: 0.0612 - val_acc: 0.9800Epoch 2/12 - 219s - loss: 0.0982 - acc: 0.9708 - val_loss: 0.0433 - val_acc: 0.9857Epoch 3/12 - 212s - loss: 0.0766 - acc: 0.9776 - val_loss: 0.0354 - val_acc: 0.9876Epoch 4/12 - 226s - loss: 0.0653 - acc: 0.9806 - val_loss: 0.0342 - val_acc: 0.9879Epoch 5/12 - 221s - loss: 0.0573 - acc: 0.9828 - val_loss: 0.0307 - val_acc: 0.9896Epoch 6/12 - 230s - loss: 0.0539 - acc: 0.9834 - val_loss: 0.0286 - val_acc: 0.9907Epoch 7/12 - 224s - loss: 0.0490 - acc: 0.9850 - val_loss: 0.0280 - val_acc: 0.9901Epoch 8/12 - 229s - loss: 0.0475 - acc: 0.9856 - val_loss: 0.0300 - val_acc: 0.9904Epoch 9/12 - 249s - loss: 0.0465 - acc: 0.9862 - val_loss: 0.0286 - val_acc: 0.9906Epoch 10/12 - 257s - loss: 0.0423 - acc: 0.9866 - val_loss: 0.0261 - val_acc: 0.9910Epoch 11/12 - 243s - loss: 0.0393 - acc: 0.9883 - val_loss: 0.0313 - val_acc: 0.9903Epoch 12/12 - 277s - loss: 0.0413 - acc: 0.9877 - val_loss: 0.0266 - val_acc: 0.9907Test loss: 0.026646837043244158Test Accuracy: 0.9907Process finished with exit code 0 如果是第一次运行，会从 https://s3.amazonaws.com/img-datasets/mnist.npz 下载数据集，Windows会存放在c://Users//&lt;User name&gt;//.keras/datasets下面；Linux会存放在home/.keras/datasets下面。 cifar10_cnn.py12 训练过程 参考 Keras Model API: https://keras.io/models/model/ mnist_cnn.py: https://github.com/keras-team/keras/blob/master/examples/mnist_cnn.py cifar10_cnn.py: https://github.com/keras-team/keras/blob/master/examples/cifar10_cnn.py https://www.cnblogs.com/lfri/p/10485597.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[李学龙老师在2017届本科生毕业典礼上的讲话]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%9D%8E%E5%AD%A6%E9%BE%99%E8%80%81%E5%B8%88%E5%9C%A82017%E5%B1%8A%E6%9C%AC%E7%A7%91%E7%94%9F%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[演讲原文尊敬的各位老师、各位家长，各位师弟、师妹们： 大家早上好！ 我想汇报和分享的很多故事其实都是“曾经”，但是我今天更想用“这一年”来说。曾经有一首歌叫《同桌的你》，曾经有一部电影叫《大话西游》，曾经有一本书叫《未来之路》，曾经在这一年我到了合肥。大约坐了将近40个小时的火车，其实完全可以加上一个注释：怀抱着光荣、梦想、期望、憧憬，但其实对我来说，当时旅途就是旅途本身，至多是一种坚持，至少当时我是这么认为的。在这一年，在北方长大的我，第一次见到了竹子，它顽强地在并不富饶的土地上茁壮成长；在这一年很多来自南方的同学，他们第一次见到了水在极端情况下的迸发和绽放。1994年的漫天大雪里，我现在还能记得很多穿着单衣的同学在欢呼雀跃。 这一年，我18岁之前建立的所有自信心都被打碎了，荡然无存，如樯橹灰飞烟灭，因为在我曾经自诩很擅长的每一个方面都有N多的人比我强。当我跟他们一样穿着拖鞋、端着饭盆去食堂的时候，总会有人说“看！这是国奥金牌，这也是国奥金牌，这是某个省的状元，这又是某个省的状元。”其实给人压力最大的并不是你知道有人比你优秀，而是你每天都要和他们在一起；也不是说你觉得比你优秀的人比你更努力，而是你发现其实他们不太努力的时候还是比你优秀。在这一年，很幸运的，我跟他们一样有了一个让我终生引以为傲、倍加珍惜的名字——科大人！ 科大人很拼，江湖传言“穷清华，富北大，不要命的上科大”。但科大就是科大，科大有自己的秉持、自己的传统、自己的文化、自己的理念，我们其实没有必要去跟别人去比。科大人很萌，像“天使路”、“勤奋路”这样的名字，如果不是情商和智商的终极极品爆发大概是想不到的。科大人很执着，1995年毕建忠（9304/9315校友）和我分别任校学生会东西区体育部长的时候，我们（重新）启动了“巾帼杯”女子足球赛，听说一直踢了二十几年，到现在还有。科大人很团结，这个不需要多说，等大家到新的学习和工作岗位上，大家自然会知道，我保证。其实科大人还有很多共同的禀赋和标签，刚才蒋书记和校长也都提到了，像“红专并进，理实交融”其实已经融进了科大人的血脉，已经刻入了科大人立德树人的骨髓。 我是早上三点半的航班到的合肥，我当时在想跟大家讲点什么呢？其实我想了讲“知道，不知道，知不道，道不知”的故事，或者给大家讲“知足，不知足，知不足”的故事。后来想了想，还是不讲这些了。因为我的资历和经历也比较有限，很多故事也是听别人讲的。所以在毕业典礼的时候，我想给大家讲两个我会对毕业生说的我的担心吧。 首先，我担心大家会以为社会上和大学里是一样的。其实我们看一下大学，从中国古代的太学到西方古典模式的大学到中西方现代模式的大学，大学始终是这么一个存在，它鼓励我们去弘扬我们的品德、砥砺我们的品格、开拓我们的视野、激发我们的潜力，让我们不断地完善和更新，达到一种更好的自我，趋于完美和完善的境地。虽然大学的入门门槛在不断地调整，但大学始终是一个象牙塔，它是社会少数精英阶层的消费。但是当我们迈向社会的时候，我们会发现，盖人生历程，大抵逆境居十之六七，顺境亦居十之三四，而顺逆两境又常相间，我们会碰到很多的困难。为什么呢？因为社会对年轻人的宽容和忍让、理解和支持同大学是不一样的。“物可瞬间无主，人须时时有心”，我们能保证不变初心，在我们的追求和志向不被外物所改变的情况下，我建议大家学会适应。达尔文在《物种起源》里说，得以生存的不见得是最强大的，也不见得是最智慧的，但一定是最适合环境的。唯一不变的事情就是变化本身，所以我送给大家的第一个词是“适应”，并请大家记住，适应绝不是随波逐流。 第二个担心是，我担心大家认为课本里学到的知识可以让大家出去生活，至少是生存了，因为生活和生存是两个概念。其实课本里的知识如果是完备的话，我们没有必要去建立一所实体大学。事实上课本里的知识、大家学过的知识很可能是不完备的，不齐整的，甚至可能是不正确的。以光学为例，我有两个透镜，有一个光轴，这边有个蜡烛，这边有个屏，蜡烛成什么样的像，这个我们可以在课本中学到，但是你在做一个实际系统的时候，这两个透镜能严格地同轴吗？或许不能！这个时候该怎么解决，课本里似乎不会告诉你。那么学电的话，我们学电子管、晶体管，并不表示我们要去用它，我们是要知道历史上发生过什么样的事情，我们应该怎么样去学习，我们要学习“学习的本领”，我们去归纳总结，去提炼升华。其实，科学研究本身至少有两个目的。第一个目的是实际的应用，去解决实际的问题。我们理工科的学生，尤其应该如此，绝对不能纸上谈兵。那么另一个目的就是满足人类对世界的好奇心。我们知道在电口（电学）上很著名的故事。当法拉第发现电磁感应定律的时候，他并不知道能做什么；麦克斯韦预言电磁波存在的时候，法拉第刚刚去世；当赫兹证明电磁波存在的时候，麦克斯韦又刚刚去世；当马可尼开始进行无线通讯的时候，赫兹也去世了。但是我们不能忘记科学史上这一步一步好奇心的驱使。其实能够鼓励创新的年代并不是特别的多，我们常说“千里马常有，而伯乐不常有”。我们看一看在欧洲，从后希腊到罗马到文艺复兴，其实创新沉睡了一千年。在中国我们有卷帙浩繁的经史子集，我们几乎可以从中间找到现在的任何一个发现或发明的原始的雏形，但是我们必须要承认，我们的技术是多于科学的，我们没有能够把炼丹术发展成化学，没有能够把观星术发展成天文学。所以在今天，在全国、全社会鼓励创新驱动发展的时候，我想大家还是非常幸运的。所以我想送给大家第二个词是“好奇”，而且好奇绝不是随心所欲。 我个人并不是特别推崇“人情练达即文章”，但是我坚信“世事洞明皆学问”。我想在大学的五年里（现在是四年制），大家至少学会了一个人的时候怎么样去平静、去思考，两个人的时候怎么样去合作、去争论，三个人的时候如何去协调、去平衡。其实我们担心的事情还很多，我们担心大家有成绩的时候妄自尊大，担心大家碰到困难的时候妄自菲薄。正因为大家很优秀，所以我们的担心才很多。 15年前的毕业典礼，我是博士生的毕业代表，到现在我还记得当时我的发言，我说“春来几度，苍翠依旧，于无声处，却已见茁壮。而今我们将成为科大的历史，但母校永远是我们心中的一座丰碑，上面镌刻着老师的关爱、同学的友情，和我们的点点滴滴……”很快大家就要离开这个校园，可能还会离开这个城市，或许很多人可能还会短期或长期离开我们的祖国，但是我深信大家或早或晚一定会回来！我是毕业6年之后回到合肥，我没有去会场，我直接打车到了黄山路的一个小饭店，进去之后，老板一句不经意的问候“很久没见了”，让我“泪飞顿作倾盆雨”，刚才在我们的校旗传过来的过程中，我心里就是这样的感觉。 我想大家一定会记得这一年，虽然这一年以后也会成为曾经，但是大家一定会记得在这一年大家收获了母校、老师、师兄师姐们的一些不可辜负的爱和期望。如果每一位科大人都是一颗闪亮的星，那么我们希望以一颗颗星的光芒去引领整个星河璀璨、瀚海星云的梦想。谢谢大家！ 演讲视频 李学龙(946)校友在2017届本科生毕业典礼上的讲话(节选)]]></content>
      <tags>
        <tag>李学龙</tag>
        <tag>演讲</tag>
        <tag>科大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[佛祖.py]]></title>
    <url>%2F2019%2F05%2F04%2F%E4%BD%9B%E7%A5%96-py%2F</url>
    <content type="text"><![CDATA[皮一下哈哈… 代码123456789101112131415161718192021222324252627282930print(" _ooOoo_ ")print(" o8888888o ")print(" 88 . 88 ")print(" (| -_- |) ")print(" O\\ = /O ")print(" ____/`---'\\____ ")print(" . ' \\| |// `. ")print(" / \\||| : |||// \\ ")print(" / _||||| -:- |||||- \\ ")print(" | | \\\\\\ - /// | | ")print(" | \\_| ''\\---/'' | | ")print(" \\ .-\\__ `-` ___/-. / ")print(" ___`. .' /--.--\\ `. . __ ")print(" ."" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'"". ")print(" | | : `- \\`.;`\\ _ /`;.`/ - ` : | | ")print(" \\ \\ `-. \\_ __\\ /__ _/ .-` / / ")print(" ======`-.____`-.___\\_____/___.-`____.-'====== ")print(" `=---=' ")print(" ")print(" ............................................. ")print(" 佛祖镇楼 BUG辟易 ")print(" 佛曰: ")print(" 写字楼里写字间，写字间里程序员； ")print(" 程序人员写程序，又拿程序换酒钱。 ")print(" 酒醒只在网上坐，酒醉还来网下眠； ")print(" 酒醉酒醒日复日，网上网下年复年。 ")print(" 但愿老死电脑间，不愿鞠躬老板前； ")print(" 奔驰宝马贵者趣，公交自行程序员。 ")print(" 别人笑我忒疯癫，我笑自己命太贱； ")print(" 不见满街漂亮妹，哪个归得程序员？") 打印效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[写出pythonic的代码]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%86%99%E5%87%BApythonic%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[列表遍历Pythonic1234names = ['juntao', 'xiaojun', 'mingming', 'haohao']# 查找名字列表中带有字母'm'的名字m_name = [name for name in names if 'm' in name]print(m_name) 不要用循环写！12345m_name = []for name in names: if 'm' in name: m_name.append(name)print(m_name) 字典遍历Pythonic1234exam_detail = &#123;'juntao': 44, 'xiaojun': 88, 'mingming': 99, 'haohao': 22&#125;# 找出及格的学生及其分数score_greater_than_60 = &#123;k: v for k, v in exam_detail.items() if v &gt;= 60&#125;print(score_greater_than_60) 不要这样写！12345score_greater_than_60 = &#123;&#125;for k, v in exam_detail.items(): if v &gt;= 60: score_greater_than_60[k] = vprint(score_greater_than_60) 参考文章 一些 pythonic 的代码实例：https://github.com/mikeckennedy/write-pythonic-code-demos https://blog.csdn.net/g8433373/article/details/80709116]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些Python语法]]></title>
    <url>%2F2019%2F05%2F01%2F%E4%B8%80%E4%BA%9BPython%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关键字 globalglobal关键字主要目的是为了在函数中使用全局变量。1234567891011121314count = 10def modify_count(): temp_count = 20 print('local variable: ', temp_count) global count print('global variable: ', count) count = 100 print('after modified: ', count) returnprint('before modify_count(): ', count)modify_count()print('after modify_count(): ', count) 输入结果：1234567before modify_count(): 10local variable: 20global variable: 10after modified: 100after modify_count(): 100Process finished with exit code 0 从代码中可以看到，，如果要在函数modify_count()中使用全局变量count，那么需要使用global关键字修饰。同时，函数内部对count的修改，将影响到函数外面count的值。 if __name__ == &#39;__main__&#39; 说明因为在 Python 中，一个.py文件就是一个模块，模块中一般写了很多函数供其他模块使用。但我们需要测试模块中函数的正确性，这时候就需要用到 if __name__ == &#39;__main__&#39;. __name__是每个模块的一个属性名，如果我们需要在当前模块中编写测试代码，一般情况下，我们是将测试代码放在 if __name__ == &#39;__main__&#39;这条判断语句下面，因为如果是直接运行当前模块，那么__name__的值就是__main__，条件判断下面的测试代码将会被执行。 如果有另外一个模块module_2.py引用了当前模块module_1.py,那么当我们运行module_2.py时，module_1.py中的__name__的值将变成module_2，即引用了module_1这个模块的模块名。那这时module_1中的if判断将不满足，也就不会执行测试代码，module_2也就只是导入了module_1中的函数，符合我们的期望。 np.random.seed()说明seed(int) 接收一个整数做为生成随机数的算法的参数。如果接收到的整数值相同，那么产生的随机数也相同。 代码123456import numpy as npnum = 0while num &lt; 5: np.random.seed(5) print(np.random.random()) num += 1 输出结果123450.221993171089739480.221993171089739480.221993171089739480.221993171089739480.22199317108973948 但是设置的seed()的值只生效一次，下次使用random()函数如果不是上次的seed()值，那么将会产生不同的随机数。 代码123456import numpy as npnum = 0np.random.seed(5)while num &lt; 5: print(np.random.random()) num += 1 输出结果123450.221993171089739480.87073230617737640.206719155339426420.91861090793792160.48841118879482914 从结果可以看到，第一次输出的random()值，由于和上面代码一样设置了seed(5)，所以第一行结果相同；但是后面4次循环由于没有继续设置seed()，因而产生的随机数不同。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm在需要输入命令行参数时如何调试]]></title>
    <url>%2F2019%2F04%2F30%2Fpycharm%E5%9C%A8%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%97%B6%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1. 前言在 pycharm 中进行调试，一般的做法是：先设置断点，然后开始调试程序。调试过程中选择step over, step into, step out, resume program等操作。 但是当程序需要从命令行中读取参数时，该怎么调试呢？ 如果和之前一样，设置断点，然后开始调试，但在这种做法下，程序没有从命令行中获取到参数；如果在 pycharm 的 teminal中输入 python xxx.py -x xx -y yy -z zz，这种做法会直接运行完程序，无法在断点处停下来。 2. 解决方法在 pycharm 中选择 Run -&gt; edit configurations，然后在parameters中填入需要设置的命令行参数，这时候不需要输入python xxx.py。点击apply然后OK。 然后在代码中就可以直接 debug 了，会在断点处停下来。 参考文章 https://blog.csdn.net/wishchin/article/details/78560725]]></content>
  </entry>
  <entry>
    <title><![CDATA[pycharm调试]]></title>
    <url>%2F2019%2F04%2F29%2Fpycharm%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[pycharm中调试功能按钮说明列表 竖排 Resume Program(F9): 运行到下一个断点。 横排 step into(F7)和step into my code(Shift+Alt+F7之间的区别：前者会进入到一些系统函数内容，后者只会进入自己定义的函数内部。 参考文章 pycharm调试功能]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下使用virtualenv新建一个python3虚拟环境]]></title>
    <url>%2F2019%2F04%2F28%2Fubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8virtualenv%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AApython3%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[1. 虚拟环境的意义因为不同的应用需要的环境可能是不同的，比方说A和B程序都需要用到第三方库C，但是A只能在C(version=1.0)下面运行，B只能在C(version=2.0)下面运行，这时要想同时运行A和B程序就会存在问题。 虚拟环境提供的好处就是，可以将不同应用程序所需要的环境隔离开来，每个程序有一套属于自己专属的环境，程序之间不会相互干扰。 2. 步骤 首先需要安装 virtualenv 1sudo apt-get install python-virtualenv 接着创建 python3 的虚拟环境(ubuntu中默认安装了python2和python3) 1234cd ~/1997tanjuntao/ # 切换到一个目录下面virtualenv -p /usr/bin/python3 py3env # 在当前目录下面创建新目录py3env(目录名可以自定义)，py3env中就是虚拟环境# 如果是新建一个python2环境，可以这样做# virtualenv -p /usr/bin/python2 py2env 接着激活环境 切换到py3env所在目录1cd ~/1997tanjuntao/ source命令激活虚拟环境1source py3env/bin/activate 这时候会发现命令行前面多了一个括号 (py3env) 这个新建的虚拟环境中使用的是python3，默认情况下，没有包含系统python3中安装的包，很干净。 这时候使用pip install安装的第三方包，只存在于这个虚拟环境中，不会影响系统中的python3 退出虚拟环境1deactivate # 一句话 参考文章 https://blog.csdn.net/qingche456/article/details/65465760]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决hexo中发布文章后图片无法显示的问题]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%90%8E%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 问题描述默认情况下，在 hexo 中新建一篇markdown博文，在文章中插入本地图片，再部署到 github 上面，是无法显示这些图片的。 2. 解决方法首先找到博客根目录下面的_config.yml文件，修改post_assrt_folder的值为true. 接着 git bash 切换到博客根目录下面，安装第三方插件hexo-assrt-image1npm install hexo-assrt-image --save 接着hexo new &quot;文章名&quot; 新建一篇文章，会发现source/_posts/目录下面会生成一个和 markdown 文件同名的文件夹。再将当前这篇文章中需要插入的图片放到这个文件夹中，再到 markdown 中引用该文件夹中的图片，最后hexo g -&gt; hexo d，就可以正常的查看这些图片了。 参考文章 https://blog.csdn.net/qq_38148394/article/details/79997971 https://www.jianshu.com/p/3db6a61d3782]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决pycharm在同目录下import，pycharm会报错，但实际可以正常运行的错误]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3pycharm%E5%9C%A8%E5%90%8C%E7%9B%AE%E5%BD%95%E4%B8%8Bimport%EF%BC%8Cpycharm%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1. 问题描述假如我们的目录结构是这样： 项目名称是HelloWorld，在项目主目录下面新建一个文件夹test_dir，接着在HelloWorld/test_dir目录下面新建两个文件: HelloWorld/test_dir/hello1.py和HelloWorld/test_dir/hello2.py。 hello1.py中插入如下代码：1234import hello2 as h2print(h2.hello_world())print(h2.nihao()) hello2.py中插入如下代码：12345def nihao(): return 'nihao'def hello_world(): return 'hello world' 此时，会发现在hello1.py中一直红线提示No module named hello2： 但是如果我们运行hello.py发现是能够正常输出结果的。 2. 解决方法在左侧工程目录树中，选中test_dir，右键，然后选择 Mark directory as，再选择source root，然后就会发现先前的红线错误提示已经没有了。 3. More…如果我们是在当前工程主目录下面新建两个文件HelloWorld/hello1.py和HelloWorld/hello2.py，两个.py文件的代码内容和之前一样，这时候却又不会出现No module named hello2这种错误了。 参考文章 https://www.zhihu.com/question/52880389/answer/134369870]]></content>
  </entry>
  <entry>
    <title><![CDATA[论论文笔记: Manipulating Machine Learning: Poisoning Attacks and Countermeasures for Regression Learning]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%AE%BA%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Manipulating-Machine-Learning-Poisoning-Attacks-and-Countermeasures-for-Regression-Learning%2F</url>
    <content type="text"><![CDATA[这篇文章发表于 2018 年，是第一篇针对线性回归模型提出投毒攻击方法的论文，实验证明：这种gradient-based的攻击方法效果很好；同时这篇文章里面也提出了一种防御方法：TRIM，实验结果也证明其防御效果很好。 主要贡献 第一篇针对linear regression进行poisoning attack的论文，之前的论文都是针对classification的模型 改造了一个原本针对分类问题进行投毒攻击的模型，将其应用在回归问题中，将攻击结果作为一个baseline 提出了一种基于数据集统计特征的攻击方法，只需要掌握有限的信息即可完成攻击 提出了防御算法TRIM,能够抵御众多的攻击，效果比传统的robust statistic好 方法Linear Regression Model传统的线性回归模型：$$\mathcal{L}\left(\mathcal{D}{\mathrm{tr}}, \boldsymbol{\theta}\right)=\underbrace{\frac{1}{n} \sum{i=1}^{n}\left(f\left(\boldsymbol{x}{i}, \boldsymbol{\theta}\right)-y{i}\right)^{2}}{\operatorname{MSE}\left(\mathcal{D}{\text { tr }}, \boldsymbol{\theta}\right)}+\lambda \Omega(\boldsymbol{w})$$ 根据$\Omega(w)$的不同，linear regression 可以分为下面4种 类型 $\Omega(w)$ Ordinary Least Square(OLS) $\Omega(w) = 0$ Ridge $\Omega(\boldsymbol{w})=\frac{1}{2}\ \boldsymbol{w}\ _{2}^{2}$ LASSO $\Omega(\boldsymbol{w}) = \ {w}_1\ $ Elastic-Net Regression $\Omega(w) = \rho\ w_1\ + (1-\rho)\frac{1}{2}\ w_2^2\ $ Adversarial Model这里定义敌手模型。 敌手模型主要是用来对潜在用户进行分析建模，例如：假设攻击者掌握了多少知识、攻击者的目标是什么、攻击者的攻击策略是什么等。具体的可以从下面4个维度来对潜在的攻击者进行建模： 维度 描述 Adversary Goal 一般包含两种:availability attack &amp; integrity attack.前者主要目的是使整个模型的可用性降低，后者主要是使模型在针对特定样本做 inference 时，准确率降低 Adversary Knowledge 一般包含两种：white-box &amp; black-box. 对于前者，假设攻击者知晓：traning data &amp; learning algorithm &amp; loss function &amp; model parameters；对于后者，假设攻击者只知晓：learning algorithm &amp; loss function。但是这篇文章中，作者通过产生替代数据，同样可以得到 model parameters. Adversary Capability 攻击者的能力，一般定义为其能往数据集中插入多少 poisoning samples. $n:original \ samples$, $p :poisoning \ samples$, $N = n + p:\ total \ smaples$, 定义poisoning rate $\alpha = p/n$ Adversary Strategy $\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$ 攻击者的目标主要是优化上面的目标函数：即如何插入 poisoning samples 来使得在 $D’$上的 loss 值最大. 攻击方法攻击者的目标函数：$$\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$$ 注： 目标函数 $W$一般用 validation set 上面的 loss 来表示。loss 越大，表名攻击效果越好。对于 linear regression, loss function = Mean Square Error(MSE) 那么该插入什么样的 poisoning sample 才能使目标函数 $W$ 的值最大呢？ 答案是：考虑梯度，考虑$W$对$D_p$的梯度。有了这个梯度，我们就能使用gradient ascent方法来更新$D_p$，直到最后$W$收敛，我们可以得到最佳的$D_p$. 但是这个优化问题是一个Bi-level问题，即约束条件本身也是一个优化问题，解决这种问题通常情况下是NP-hard.因为$x_c$和$W$并不是显示相关，而是通过$\theta$间接相关，因此作者通过chain rule来计算所需要的梯度 $\nabla_{\boldsymbol{x}_{c}} \mathcal{W}$: $$\nabla_{\boldsymbol{x}{c}} \mathcal{W}=\nabla{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top} \cdot \nabla_{\boldsymbol{\theta}} \mathcal{W}$$ 注：$x_c$表示 poisoning sample 的 features 1. 首先求解公式的第二项 $\nabla_{\theta} \mathcal{W}$ 第二项比较好计算，因为在线性回归问题中，目标函数表示的是在 validation set 上计算到的 loss： $$\mathcal{W}{\mathrm{val}}\left(\mathcal{D}{\mathrm{val}}, \boldsymbol{\theta}\right)=\frac{1}{m} \sum_{j=1}^{m}\left(f\left(\boldsymbol{x}{j}^{\prime}, \boldsymbol{\theta}\right)-y{j}^{\prime}\right)^{2}$$ 对这个函数求对$\theta$的偏导：$$\nabla_{\boldsymbol{\theta}} \mathcal{W}{\mathrm{val}}=\left[ \begin{array}{c}{\nabla{\boldsymbol{w}} \mathcal{W}{\mathrm{val}}} \ {\nabla{b} \mathcal{W}{\mathrm{val}}}\end{array}\right]=\left[ \begin{array}{c}{\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right) \boldsymbol{x}{j}} \ {\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right)}\end{array}\right]$$ 至此，公式第二项偏导数计算完毕，下面计算第一项。 2. 求解公式第二项 $\nabla_{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top}$ 防御方法实验结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH公钥方式登录原理以及对称加密和非对称加密知识点总结]]></title>
    <url>%2F2019%2F04%2F10%2FSSH%E5%85%AC%E9%92%A5%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先占坑，后面需要学习这块的内容，用博客记录下来，加深理解！ 参考文章 https://blog.csdn.net/csm201314/article/details/78453579]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统中常见目录的含义及作用]]></title>
    <url>%2F2019%2F04%2F02%2FLinux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言这篇博客将随着我对 Linux 系统的不断使用和了解而不定期更新。 常用目录的含义 目录 含义 /bin 存放 linux 中常用命令，如cd pwd ls等 /lib /etc /var 参考文章 http://blog.sina.com.cn/s/blog_684d52a90102uw30.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装固态硬盘]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%AE%89%E8%A3%85%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[0.前言以下全是个人的装机经验，没有很认真的写，只是打算做个记录，这样下次如果还需要干这类活时有个参考。不建议follow！！仅供一点参考。 笔记本老早就出现各种问题了，觉得应该是系统的问题而不是硬件的问题，于是寻思着重装一下系统。但是心里对重装系统有些抵触，因为会导致很多之前辛苦安装好配置好的软件无法使用。拖了好久，终于买了一块固态硬盘来重装系统…笔记本简直焕发第二春啊！ 1. 数据备份 为了避免发生意外情况，建议还是首先把原先硬盘中重要的文件备份一下。所谓备份，就是把一些重要的文件拷贝到另外一块存储介质中，如移动硬盘等，这样重装系统能够放心点。 其实需要备份的文件感觉不是很多，个人觉得下面这些需要着重备份： C盘：桌面，图片，视频。偷懒一点，就把user文件夹全部备份一下，因为这个差不多是系统盘中最重要的文件了。 其它：如果是数据盘，那不用考虑，所有的文件都得备份。如果是软件盘，那么之前一些工程文件目录，如eclipse，webstorm，pycharm等，做好备份。另外Tim，微信聊天记录也最好备份一下，这样重装之后可以直接导入这些记录。 2. 制作启动U盘因为打算把新系统装到 SSD 中，所以需要事先制作一个启动 U 盘，用来安装新系统。 下载系统iso镜像 可以使用微软官方的渠道下载，直接搜索windows10镜像下载 微软，然后下载一个工具，让其将Windows操作提供写入到U盘中(U盘会被格式化，事先备份U盘) 也可以使用第三方的镜像，比较推荐的是 MSDN我告诉你。找到打算下载的镜像，将完整的ed2k地址复制到迅雷等下载工具中，启动镜像下载。 制作启动U盘 可以使用UltraISO rufus等启动U盘制作工具，导入之前下载的iso镜像，就可以轻松完成U盘制作。 3. 拆机拆机过程中不用太担心，小心操作，一般不会带来什么问题的。拆机之前记得先把笔记本电源取下来，防止意外发生。 将笔记本后盖中所有看得见的螺丝全部拧下来，然后将笔记本后盖和主板分离。这个过程中需要留意一点，因为主板上面有可能有线和后盖通过一个卡口连在一块，所以在取下后盖之前，需要将这个卡口解开，不能直接就分离后盖。 找到硬盘位。拧下所有的螺丝，将原来的 HDD 取下，装上新的 SSD，按照相反的步骤再装回原位，这样新的固态硬盘就轻松的装好了。 找到光驱位。拧下所有的螺丝，将原来的 HDD 装入光驱位硬盘托架(需花钱额外购买)，记得一定要将 HDD 装到位，也就是一定要保证接线口是完全缝合的，否则可能在装好新系统后，无法读取到这块 HDD 硬盘。 将原来光驱的前挡板取下来，装到这块硬盘托架上，这样能够保证托架装上笔记本后，不会明显的凹下去，因为如果使用硬盘托架厂商送的通用挡板，会导致笔记本装好后没有一体性，因为光驱位那里凹下去了，影响美观。 将后盖装回去(有线的地方先把线接好)，再将所有的螺丝全部拧回去，这样就完成了拆机安装 SSD 的过程。 4. 重装系统到 SSD目标是将新系统装到 SSD 中，原来的 HDD 作为普通的硬盘使用。 具体的，笔记本开机后，不断按f2 f8 delete(不同笔记本不同)进入BIOS。找到boot，选择从U盘启动。 这时候会识别到刚才新装的固态硬盘，会提示是否需要进行分区，因为SSD一般是128G或者256G，感觉没有必要再分区了，整块盘作为一个分区就可以了。然后接下来就是愉悦的安装过程了，这个比较傻瓜，没什么好说的。 5. 可能的问题 新系统中无法使用触控板。可以卸载当前的触控板驱动，然后去笔记本厂商官网，找到当前这款型号笔记本对应的触控板驱动程序，重新安装就可以了。 读取不到光驱位硬盘。可以搜索一下这个问题，一般会提示让下载一个amd xxx controller，然后打开设备管理器，将驱动程序手动更新一下就可以了。 原先的光驱挡板不好拆卸。实在不行就暴力拆卸，装到托架上时，用502胶水粘一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的正则匹配]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[正则表达式由两个部分组成：1/正则表达式主体/修饰符(可选) 其中修饰符主要用到两种： i: ignore 的意思。表示忽略大小写进行匹配。 g: global 的意思。表示匹配整个字符串，否则第一次匹配成功后，不会继续匹配后面的字符串。 常用的特殊字符 特殊字符 含义 * 0个或者 N 个 + 1个或者 N 个 ? 0个或者1个 .等价[^\n\r] 匹配任意字符(除了换行和回车) \ 可以做转义字符也可以和\b等一起使用表示特殊含义 ^ 匹配输入的开始如/^A/匹配一个以字符A开头的字符串 $ 匹配输入的结束如/t$/匹配一个以字符t结尾的字符串 [0-9] 匹配一个数字 \d 同上匹配一个数字 \s 空白字符(空格、制表符、换行符等) \D等价[^0-9] 匹配一个非数字字符 [a-zA-Z] 匹配任何一个大小写字母 \w 匹配一个单字字符(字符、数字、下划线) \W 同上匹配一个非单字字符 [^xyz] 匹配不包含xyz字符的第一个字符 使用正则表达式的常用方法 方法 描述 replace() 查找匹配的字符串，然后用新字符串替代 split() 将原字符串按照正则表达式拆分，将结果存入到一个数组中 使用括号的子字符串匹配 这种情况下，会将匹配的结果存入到一个数组中，也就是会 记忆 匹配得到的结果。 几个例子 eg1 1234var re = /\w+\s/g;var str = "fee fi fo fum";var myarr = str.match(re);console.log(myarr); 输出结果1["fee+空格", "fi+空格", "fo+空格"] eg2(综合性实例) 1234567891011121314151617181920212223// names中不同名字之间有多个空白字符、制表符等不可见字符var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";console.log("===========original string==============\n" + names);var pattern = /\s*;\s*/;var namelist = names.split(pattern);// console.log(namelist);// 将匹配到的结果存起来作为$1和$2var newpattern = /(\w+)\s+(\w+)/;newnamelist = [];for (var i = 0, len = namelist.length; i &lt; len; i++) &#123; // 名字颠倒 newnamelist[i] = namelist[i].replace(newpattern, "$2, $1");&#125;console.log(newnamelist);// 按照字母表排序newnamelist.sort();console.log(newnamelist); 需要注意的就是函数split()和replace()的使用。 如果是带有括号的，那么匹配的结果将存放在$1 $2 … $n中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Office 2016 激活方法]]></title>
    <url>%2F2019%2F04%2F02%2FOffice-2016-%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[激活方法 下载安装激活工具：链接: https://pan.baidu.com/s/1C3KqB4m7dnm9t2uKoDARHw 提取码: 9r4h Windows 10 中可能会提示说下载的文件中包含病毒，导致下载不成功。这时候只需要在Windows defender中找到刚才那条阻止记录，并将其设置为允许，重新下载文件，就可以下载成功了。 接下来执行压缩包里面的.exe文件，安装到最后，Windows defender又提示说检测到病毒xxx不能执行，安装失败之类的，这时候需要在windows安全中心，选择管理设置，然后关闭实时保护，然后以管理员方式运行压缩包里面的.bat文件，再重新安装刚才那个.exe文件，这时候就可以成功安装了，安装完之后再开启实时保护。 启动软件，点击红色按钮，在打开 office 中的账户，发现已经激活成功了，简直神器！ 参考文章 https://blog.csdn.net/weixin_40941966/article/details/80872533]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3: ModuleNotFoundError: No module named 'PIL']]></title>
    <url>%2F2019%2F04%2F02%2FPython3-ModuleNotFoundError-No-module-named-PIL%2F</url>
    <content type="text"><![CDATA[问题使用matplotlib.pyplot模块调用绘图函数时，出现以上错误。 解决方法在控制台中输入如下命令1pip install pillow 即可解决问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Github Pages + Hexo 搭建一个个人博客]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%BD%BF%E7%94%A8-Github-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言其实在很早之前，曾使用 WordPress 搭建过一个个人博客。当时也是满满的激情，想模仿大佬们学着写技术博客。但是后来由于忙着追求GPA，加上自身懒惰自控力不行，博客就基本放弃更新了。 但是现在已经过上了研究生生活，每天有大把的时间可以由自己来支配，同时接触的东西也越来越多：做项目需要实时的学习一些技术和技巧，需要不断总结下来；各种学术报告会，听完之后需要回去再认真揣摩消化，变成自己的东西，这也需要总结下来。虽然之前也零零散散的做了一些笔记，但是组织松散不方便查找，遂考虑重新开通个人博客，将平常生活中的所学所思都记录下来，做技术和科研的积淀，争取能够厚积薄发！ 开始搭建 1. 前期准备 安装node.js：因为hexo是一个基于node.js开发的静态博客框架，其运行必须要有node.js环境支持 安装git：要往 github 提交代码，就必须先在本地安装好 git 客户端 在 github 上面新建一个仓库，名称设为你的github账户名.github.io 上面软件的安装应该没有大问题，去官网下载一路 next 基本就可以了。需要注意的是，如果之前没有用过 git 提交代码到 github，那么第一次安装 git 之后还需要做些 SSH Key 的设置，这里不打算赘述这个步骤。 2. 安装hexo打开 git bash，直接输入下面这条命令：1npm install -g hexo-cli 安装可能需要几分钟，耐心等待，不出意外的话，能够成功安装 hexo 3. 构建本地目录在本地文件系统中，任意找一个目录作为网站文件的存放目录，比如在 D盘 新建一个目录blog，作为网站所有文件存放的根目录。 在 git bash 中进入这个目录12cd d:cd blog/ 下载安装 hexo 博客系统所需要的各种文件1npm install 安装过程可能比较慢，且没有进度条提示。安装完之后，在blog目录下面会产生很多新的目录，简单解释一下几个常用目录和文件的含义及作用 themes：存放所有的博客主题，hexo 默认安装的主题是 landscape source: 存放所有的 markdown 源文件。所有新建的博文(post) 都存放在source/_posts/ 这个目录下面。如果后面新建了其它页面，比如关于，归档，标签等，那么在source目录下面将会新产生about, achieve, tag等目录。 public：这个目录中存放所有的网页文件，html,css, javascirpt等等。简单说，hexo 会将我们编写的 markdown 文件解析成 html 文件，同时配套生成一些 css 样式文件，进而保护 markdown 源文件不被其他人获取。 _config.yml：全局的配置文件，可以配置网站 标题, 子标题 等 4. 启动前面安装步骤顺利完成之后，就可以在本地启动 hexo 了。 1npm server # 或者是 npm s, 效果等价 这时会提示说在localhost:4000端口可以访问刚刚建立的博客，正常情况下，如果4000端口没有被占用的话，那么就可以正常访问到博客，会有一篇默认的Hello World的博文。如果4000端口被占用了，具体的表现就是网站打不开，那么可以尝试更换一个启动端口，具体命令可以自行搜索。 5. 部署到 Github Page在部署到 github page之前，需要在本地修改一些配置。 首先打开_config.yml，搜索deploy字段，修改为如下格式：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tanjuntao/tanjuntao.github.io.git branch: master 其中第二个repo字段的值，需要改为你在 github 上面那个网站项目对应的 SSH 值，也不打算截图介绍这个 SSH 值是怎么获取到的了。需要注意的是每个:后面需要紧跟一个空格，否则会出错！ 接着，在 git bash 中执行下面的命令：1npm install hexo-deployer-git --save 执行这条命令可能会出错，解决办法是 npm + flush刷新一下缓存, 具体的命令记不清楚。 最后就可以 deploy 到远程的 github 上面了。 1hexo deploy # 或者 hexo d, 效果是一样的 这时候，就可以看到 github 仓库里面生成了很多文件，但是找不到 source 文件夹，这就是前面介绍到的，保护了源文件。 要通过github账户名.github.io方式访问网站，还需要在项目仓库中的setting中设置中找到github page，设置一下后，才能够访问到。 6. 使用后面当需要新建一篇博文时，只需要做下面三个步骤，非常方便！1234hexo new &quot;博文标题&quot;hexo generate # hexo ghexo server # hexo s, 启动本地服务，可在本地中预览效果，这步可选hexo deploy # hexo d 7. 修改主题hexo 中默认使用的主题是landscape,但最为流行的一个主题叫next，打算安装next主题的可以接着往下看。 首先切换到博客更目录下面，也就是前面的blog/目录，执行下面命令：1git clone https://github.com/iissnan/hexo-theme-next themes/next 可能需要一段时间才能完成。 接着打开跟目录下面的_config.yml文件，修改theme字段的值为next就可以了。 如果后期打算更换其它主题，只需要修改这个theme的值就可以了，同样非常方便！ next主题默认的样式还是没有符合我的要求：左边有一个导航栏，且有关于 分类 标签 这些选项，我们还需要进一步对主题进行设置。 在/theme/next/目录中找到_config.yml文件，同样是一个设置文件，只不过仅仅是next这个主题的设置文件。 搜索Scheme，修改其值为Pisces或者Gemini，因为只有这两个 scheme 能显示左右侧边栏。 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 接着搜索sidebar，参考下列注释进行设置：12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 其它一些设置，包括头像，新页面，评论系统等，可以参见Hexo的Next主题详细配置 这篇文章，非常详细！ 8.其它关于使用 hexo deploy时，如何附带像git commit那样的message，只需要如下命令即可：1hexo deploy --message &quot;提交的信息内容&quot; 非常方便！ 9.注意事项 不要修改使用hexo new命令生成的文章标题 在编辑hexo new生成的 markdown 文件时，不要动手修改title的值，否则会导致这篇post无法显示在网站上！ 这篇文章就先到这里啦~ 主要参考 https://segmentfault.com/q/1010000007139908 https://www.jianshu.com/p/3a05351a37dc https://www.jianshu.com/p/40e4349a0cc7]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试博文]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[二级标题：测试markdown语法的支持情况 有序列表 有序列表 无序列表 无序列表 这里是引用内容 123import tensorflow as tfimport numpy as npprint('hello world') 这是行内代码，这是加粗，这是斜体]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
