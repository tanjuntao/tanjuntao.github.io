<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决hexo中发布文章后图片无法显示的问题]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%90%8E%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 问题描述默认情况下，在 hexo 中新建一篇markdown博文，在文章中插入本地图片，再部署到 github 上面，是无法显示这些图片的。 2. 解决方法首先找到博客根目录下面的_config.yml文件，修改post_assrt_folder的值为true. 接着 git bash 切换到博客根目录下面，安装第三方插件hexo-assrt-image1npm install hexo-assrt-image --save 接着hexo new &quot;文章名&quot; 新建一篇文章，会发现source/_posts/目录下面会生成一个和 markdown 文件同名的文件夹。再将当前这篇文章中需要插入的图片放到这个文件夹中，再到 markdown 中引用该文件夹中的图片，最后hexo g -&gt; hexo d，就可以正常的查看这些图片了。 参考文章 https://blog.csdn.net/qq_38148394/article/details/79997971 https://www.jianshu.com/p/3db6a61d3782]]></content>
  </entry>
  <entry>
    <title><![CDATA[解决pycharm在同目录下import，pycharm会报错，但实际可以正常运行的错误]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%A7%A3%E5%86%B3pycharm%E5%9C%A8%E5%90%8C%E7%9B%AE%E5%BD%95%E4%B8%8Bimport%EF%BC%8Cpycharm%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[1. 问题描述假如我们的目录结构是这样： 项目名称是HelloWorld，在项目主目录下面新建一个文件夹test_dir，接着在HelloWorld/test_dir目录下面新建两个文件: HelloWorld/test_dir/hello1.py和HelloWorld/test_dir/hello2.py。 hello1.py中插入如下代码：1234import hello2 as h2print(h2.hello_world())print(h2.nihao()) hello2.py中插入如下代码：12345def nihao(): return 'nihao'def hello_world(): return 'hello world' 此时，会发现在hello1.py中一直红线提示No module named hello2： 但是如果我们运行hello.py发现是能够正常输出结果的。 2. 解决方法在左侧工程目录树中，选中test_dir，右键，然后选择 Mark directory as，再选择source root，然后就会发现先前的红线错误提示已经没有了。 3. More…如果我们是在当前工程主目录下面新建两个文件HelloWorld/hello1.py和HelloWorld/hello2.py，两个.py文件的代码内容和之前一样，这时候却又不会出现No module named hello2这种错误了。 参考文章 https://www.zhihu.com/question/52880389/answer/134369870]]></content>
  </entry>
  <entry>
    <title><![CDATA[论论文笔记: Manipulating Machine Learning: Poisoning Attacks and Countermeasures for Regression Learning]]></title>
    <url>%2F2019%2F04%2F18%2F%E8%AE%BA%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Manipulating-Machine-Learning-Poisoning-Attacks-and-Countermeasures-for-Regression-Learning%2F</url>
    <content type="text"><![CDATA[这篇文章发表于 2018 年，是第一篇针对线性回归模型提出投毒攻击方法的论文，实验证明：这种gradient-based的攻击方法效果很好；同时这篇文章里面也提出了一种防御方法：TRIM，实验结果也证明其防御效果很好。 主要贡献 第一篇针对linear regression进行poisoning attack的论文，之前的论文都是针对classification的模型 改造了一个原本针对分类问题进行投毒攻击的模型，将其应用在回归问题中，将攻击结果作为一个baseline 提出了一种基于数据集统计特征的攻击方法，只需要掌握有限的信息即可完成攻击 提出了防御算法TRIM,能够抵御众多的攻击，效果比传统的robust statistic好 方法Linear Regression Model传统的线性回归模型：$$\mathcal{L}\left(\mathcal{D}{\mathrm{tr}}, \boldsymbol{\theta}\right)=\underbrace{\frac{1}{n} \sum{i=1}^{n}\left(f\left(\boldsymbol{x}{i}, \boldsymbol{\theta}\right)-y{i}\right)^{2}}{\operatorname{MSE}\left(\mathcal{D}{\text { tr }}, \boldsymbol{\theta}\right)}+\lambda \Omega(\boldsymbol{w})$$ 根据$\Omega(w)$的不同，linear regression 可以分为下面4种 类型 $\Omega(w)$ Ordinary Least Square(OLS) $\Omega(w) = 0$ Ridge $\Omega(\boldsymbol{w})=\frac{1}{2}\ \boldsymbol{w}\ _{2}^{2}$ LASSO $\Omega(\boldsymbol{w}) = \ {w}_1\ $ Elastic-Net Regression $\Omega(w) = \rho\ w_1\ + (1-\rho)\frac{1}{2}\ w_2^2\ $ Adversarial Model这里定义敌手模型。 敌手模型主要是用来对潜在用户进行分析建模，例如：假设攻击者掌握了多少知识、攻击者的目标是什么、攻击者的攻击策略是什么等。具体的可以从下面4个维度来对潜在的攻击者进行建模： 维度 描述 Adversary Goal 一般包含两种:availability attack &amp; integrity attack.前者主要目的是使整个模型的可用性降低，后者主要是使模型在针对特定样本做 inference 时，准确率降低 Adversary Knowledge 一般包含两种：white-box &amp; black-box. 对于前者，假设攻击者知晓：traning data &amp; learning algorithm &amp; loss function &amp; model parameters；对于后者，假设攻击者只知晓：learning algorithm &amp; loss function。但是这篇文章中，作者通过产生替代数据，同样可以得到 model parameters. Adversary Capability 攻击者的能力，一般定义为其能往数据集中插入多少 poisoning samples. $n:original \ samples$, $p :poisoning \ samples$, $N = n + p:\ total \ smaples$, 定义poisoning rate $\alpha = p/n$ Adversary Strategy $\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$ 攻击者的目标主要是优化上面的目标函数：即如何插入 poisoning samples 来使得在 $D’$上的 loss 值最大. 攻击方法攻击者的目标函数：$$\begin{array}{rl}{\arg \max {\mathcal{D}{p}}} &amp; {\mathcal{W}\left(\mathcal{D}^{\prime}, \boldsymbol{\theta}{p}^{\star}\right)} \ {\text { s.t. }} &amp; {\boldsymbol{\theta}{p}^{\star} \in \arg \min {\boldsymbol{\theta}} \mathcal{L}\left(\mathcal{D}{\mathrm{tr}} \cup \mathcal{D}_{p}, \boldsymbol{\theta}\right)}\end{array}$$ 注： 目标函数 $W$一般用 validation set 上面的 loss 来表示。loss 越大，表名攻击效果越好。对于 linear regression, loss function = Mean Square Error(MSE) 那么该插入什么样的 poisoning sample 才能使目标函数 $W$ 的值最大呢？ 答案是：考虑梯度，考虑$W$对$D_p$的梯度。有了这个梯度，我们就能使用gradient ascent方法来更新$D_p$，直到最后$W$收敛，我们可以得到最佳的$D_p$. 但是这个优化问题是一个Bi-level问题，即约束条件本身也是一个优化问题，解决这种问题通常情况下是NP-hard.因为$x_c$和$W$并不是显示相关，而是通过$\theta$间接相关，因此作者通过chain rule来计算所需要的梯度 $\nabla_{\boldsymbol{x}_{c}} \mathcal{W}$: $$\nabla_{\boldsymbol{x}{c}} \mathcal{W}=\nabla{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top} \cdot \nabla_{\boldsymbol{\theta}} \mathcal{W}$$ 注：$x_c$表示 poisoning sample 的 features 1. 首先求解公式的第二项 $\nabla_{\theta} \mathcal{W}$ 第二项比较好计算，因为在线性回归问题中，目标函数表示的是在 validation set 上计算到的 loss： $$\mathcal{W}{\mathrm{val}}\left(\mathcal{D}{\mathrm{val}}, \boldsymbol{\theta}\right)=\frac{1}{m} \sum_{j=1}^{m}\left(f\left(\boldsymbol{x}{j}^{\prime}, \boldsymbol{\theta}\right)-y{j}^{\prime}\right)^{2}$$ 对这个函数求对$\theta$的偏导：$$\nabla_{\boldsymbol{\theta}} \mathcal{W}{\mathrm{val}}=\left[ \begin{array}{c}{\nabla{\boldsymbol{w}} \mathcal{W}{\mathrm{val}}} \ {\nabla{b} \mathcal{W}{\mathrm{val}}}\end{array}\right]=\left[ \begin{array}{c}{\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right) \boldsymbol{x}{j}} \ {\frac{2}{m} \sum{j=1}^{m}\left(f\left(\boldsymbol{x}{j}\right)-y{j}\right)}\end{array}\right]$$ 至此，公式第二项偏导数计算完毕，下面计算第一项。 2. 求解公式第二项 $\nabla_{\boldsymbol{x}{c}} \boldsymbol{\theta}\left(\boldsymbol{x}{c}\right)^{\top}$ 防御方法实验结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH公钥方式登录原理以及对称加密和非对称加密知识点总结]]></title>
    <url>%2F2019%2F04%2F10%2FSSH%E5%85%AC%E9%92%A5%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先占坑，后面需要学习这块的内容，用博客记录下来，加深理解！ 参考文章 https://blog.csdn.net/csm201314/article/details/78453579]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 系统中常见目录的含义及作用]]></title>
    <url>%2F2019%2F04%2F02%2FLinux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言这篇博客将随着我对 Linux 系统的不断使用和了解而不定期更新。 常用目录的含义 目录 含义 /bin 存放 linux 中常用命令，如cd pwd ls等 /lib /etc /var 参考文章 http://blog.sina.com.cn/s/blog_684d52a90102uw30.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装固态硬盘]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%AE%89%E8%A3%85%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[0.前言以下全是个人的装机经验，没有很认真的写，只是打算做个记录，这样下次如果还需要干这类活时有个参考。不建议follow！！仅供一点参考。 笔记本老早就出现各种问题了，觉得应该是系统的问题而不是硬件的问题，于是寻思着重装一下系统。但是心里对重装系统有些抵触，因为会导致很多之前辛苦安装好配置好的软件无法使用。拖了好久，终于买了一块固态硬盘来重装系统…笔记本简直焕发第二春啊！ 1. 数据备份 为了避免发生意外情况，建议还是首先把原先硬盘中重要的文件备份一下。所谓备份，就是把一些重要的文件拷贝到另外一块存储介质中，如移动硬盘等，这样重装系统能够放心点。 其实需要备份的文件感觉不是很多，个人觉得下面这些需要着重备份： C盘：桌面，图片，视频。偷懒一点，就把user文件夹全部备份一下，因为这个差不多是系统盘中最重要的文件了。 其它：如果是数据盘，那不用考虑，所有的文件都得备份。如果是软件盘，那么之前一些工程文件目录，如eclipse，webstorm，pycharm等，做好备份。另外Tim，微信聊天记录也最好备份一下，这样重装之后可以直接导入这些记录。 2. 制作启动U盘因为打算把新系统装到 SSD 中，所以需要事先制作一个启动 U 盘，用来安装新系统。 下载系统iso镜像 可以使用微软官方的渠道下载，直接搜索windows10镜像下载 微软，然后下载一个工具，让其将Windows操作提供写入到U盘中(U盘会被格式化，事先备份U盘) 也可以使用第三方的镜像，比较推荐的是 MSDN我告诉你。找到打算下载的镜像，将完整的ed2k地址复制到迅雷等下载工具中，启动镜像下载。 制作启动U盘 可以使用UltraISO rufus等启动U盘制作工具，导入之前下载的iso镜像，就可以轻松完成U盘制作。 3. 拆机拆机过程中不用太担心，小心操作，一般不会带来什么问题的。拆机之前记得先把笔记本电源取下来，防止意外发生。 将笔记本后盖中所有看得见的螺丝全部拧下来，然后将笔记本后盖和主板分离。这个过程中需要留意一点，因为主板上面有可能有线和后盖通过一个卡口连在一块，所以在取下后盖之前，需要将这个卡口解开，不能直接就分离后盖。 找到硬盘位。拧下所有的螺丝，将原来的 HDD 取下，装上新的 SSD，按照相反的步骤再装回原位，这样新的固态硬盘就轻松的装好了。 找到光驱位。拧下所有的螺丝，将原来的 HDD 装入光驱位硬盘托架(需花钱额外购买)，记得一定要将 HDD 装到位，也就是一定要保证接线口是完全缝合的，否则可能在装好新系统后，无法读取到这块 HDD 硬盘。 将原来光驱的前挡板取下来，装到这块硬盘托架上，这样能够保证托架装上笔记本后，不会明显的凹下去，因为如果使用硬盘托架厂商送的通用挡板，会导致笔记本装好后没有一体性，因为光驱位那里凹下去了，影响美观。 将后盖装回去(有线的地方先把线接好)，再将所有的螺丝全部拧回去，这样就完成了拆机安装 SSD 的过程。 4. 重装系统到 SSD目标是将新系统装到 SSD 中，原来的 HDD 作为普通的硬盘使用。 具体的，笔记本开机后，不断按f2 f8 delete(不同笔记本不同)进入BIOS。找到boot，选择从U盘启动。 这时候会识别到刚才新装的固态硬盘，会提示是否需要进行分区，因为SSD一般是128G或者256G，感觉没有必要再分区了，整块盘作为一个分区就可以了。然后接下来就是愉悦的安装过程了，这个比较傻瓜，没什么好说的。 5. 可能的问题 新系统中无法使用触控板。可以卸载当前的触控板驱动，然后去笔记本厂商官网，找到当前这款型号笔记本对应的触控板驱动程序，重新安装就可以了。 读取不到光驱位硬盘。可以搜索一下这个问题，一般会提示让下载一个amd xxx controller，然后打开设备管理器，将驱动程序手动更新一下就可以了。 原先的光驱挡板不好拆卸。实在不行就暴力拆卸，装到托架上时，用502胶水粘一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用的正则匹配]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[正则表达式由两个部分组成：1/正则表达式主体/修饰符(可选) 其中修饰符主要用到两种： i: ignore 的意思。表示忽略大小写进行匹配。 g: global 的意思。表示匹配整个字符串，否则第一次匹配成功后，不会继续匹配后面的字符串。 常用的特殊字符 特殊字符 含义 * 0个或者 N 个 + 1个或者 N 个 ? 0个或者1个 .等价[^\n\r] 匹配任意字符(除了换行和回车) \ 可以做转义字符也可以和\b等一起使用表示特殊含义 ^ 匹配输入的开始如/^A/匹配一个以字符A开头的字符串 $ 匹配输入的结束如/t$/匹配一个以字符t结尾的字符串 [0-9] 匹配一个数字 \d 同上匹配一个数字 \s 空白字符(空格、制表符、换行符等) \D等价[^0-9] 匹配一个非数字字符 [a-zA-Z] 匹配任何一个大小写字母 \w 匹配一个单字字符(字符、数字、下划线) \W 同上匹配一个非单字字符 [^xyz] 匹配不包含xyz字符的第一个字符 使用正则表达式的常用方法 方法 描述 replace() 查找匹配的字符串，然后用新字符串替代 split() 将原字符串按照正则表达式拆分，将结果存入到一个数组中 使用括号的子字符串匹配 这种情况下，会将匹配的结果存入到一个数组中，也就是会 记忆 匹配得到的结果。 几个例子 eg1 1234var re = /\w+\s/g;var str = "fee fi fo fum";var myarr = str.match(re);console.log(myarr); 输出结果1["fee+空格", "fi+空格", "fo+空格"] eg2(综合性实例) 1234567891011121314151617181920212223// names中不同名字之间有多个空白字符、制表符等不可见字符var names = "Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ; Chris Hand ";console.log("===========original string==============\n" + names);var pattern = /\s*;\s*/;var namelist = names.split(pattern);// console.log(namelist);// 将匹配到的结果存起来作为$1和$2var newpattern = /(\w+)\s+(\w+)/;newnamelist = [];for (var i = 0, len = namelist.length; i &lt; len; i++) &#123; // 名字颠倒 newnamelist[i] = namelist[i].replace(newpattern, "$2, $1");&#125;console.log(newnamelist);// 按照字母表排序newnamelist.sort();console.log(newnamelist); 需要注意的就是函数split()和replace()的使用。 如果是带有括号的，那么匹配的结果将存放在$1 $2 … $n中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Office 2016 激活方法]]></title>
    <url>%2F2019%2F04%2F02%2FOffice-2016-%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[激活方法 下载安装激活工具：链接: https://pan.baidu.com/s/1C3KqB4m7dnm9t2uKoDARHw 提取码: 9r4h Windows 10 中可能会提示说下载的文件中包含病毒，导致下载不成功。这时候只需要在Windows defender中找到刚才那条阻止记录，并将其设置为允许，重新下载文件，就可以下载成功了。 接下来执行压缩包里面的.exe文件，安装到最后，Windows defender又提示说检测到病毒xxx不能执行，安装失败之类的，这时候需要在windows安全中心，选择管理设置，然后关闭实时保护，然后以管理员方式运行压缩包里面的.bat文件，再重新安装刚才那个.exe文件，这时候就可以成功安装了，安装完之后再开启实时保护。 启动软件，点击红色按钮，在打开 office 中的账户，发现已经激活成功了，简直神器！ 参考文章 https://blog.csdn.net/weixin_40941966/article/details/80872533]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3: ModuleNotFoundError: No module named 'PIL']]></title>
    <url>%2F2019%2F04%2F02%2FPython3-ModuleNotFoundError-No-module-named-PIL%2F</url>
    <content type="text"><![CDATA[问题使用matplotlib.pyplot模块调用绘图函数时，出现以上错误。 解决方法在控制台中输入如下命令1pip install pillow 即可解决问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Github Pages + Hexo 搭建一个个人博客]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%BD%BF%E7%94%A8-Github-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言其实在很早之前，曾使用 WordPress 搭建过一个个人博客。当时也是满满的激情，想模仿大佬们学着写技术博客。但是后来由于忙着追求GPA，加上自身懒惰自控力不行，博客就基本放弃更新了。 但是现在已经过上了研究生生活，每天有大把的时间可以由自己来支配，同时接触的东西也越来越多：做项目需要实时的学习一些技术和技巧，需要不断总结下来；各种学术报告会，听完之后需要回去再认真揣摩消化，变成自己的东西，这也需要总结下来。虽然之前也零零散散的做了一些笔记，但是组织松散不方便查找，遂考虑重新开通个人博客，将平常生活中的所学所思都记录下来，做技术和科研的积淀，争取能够厚积薄发！ 开始搭建 1. 前期准备 安装node.js：因为hexo是一个基于node.js开发的静态博客框架，其运行必须要有node.js环境支持 安装git：要往 github 提交代码，就必须先在本地安装好 git 客户端 在 github 上面新建一个仓库，名称设为你的github账户名.github.io 上面软件的安装应该没有大问题，去官网下载一路 next 基本就可以了。需要注意的是，如果之前没有用过 git 提交代码到 github，那么第一次安装 git 之后还需要做些 SSH Key 的设置，这里不打算赘述这个步骤。 2. 安装hexo打开 git bash，直接输入下面这条命令：1npm install -g hexo-cli 安装可能需要几分钟，耐心等待，不出意外的话，能够成功安装 hexo 3. 构建本地目录在本地文件系统中，任意找一个目录作为网站文件的存放目录，比如在 D盘 新建一个目录blog，作为网站所有文件存放的根目录。 在 git bash 中进入这个目录12cd d:cd blog/ 下载安装 hexo 博客系统所需要的各种文件1npm install 安装过程可能比较慢，且没有进度条提示。安装完之后，在blog目录下面会产生很多新的目录，简单解释一下几个常用目录和文件的含义及作用 themes：存放所有的博客主题，hexo 默认安装的主题是 landscape source: 存放所有的 markdown 源文件。所有新建的博文(post) 都存放在source/_posts/ 这个目录下面。如果后面新建了其它页面，比如关于，归档，标签等，那么在source目录下面将会新产生about, achieve, tag等目录。 public：这个目录中存放所有的网页文件，html,css, javascirpt等等。简单说，hexo 会将我们编写的 markdown 文件解析成 html 文件，同时配套生成一些 css 样式文件，进而保护 markdown 源文件不被其他人获取。 _config.yml：全局的配置文件，可以配置网站 标题, 子标题 等 4. 启动前面安装步骤顺利完成之后，就可以在本地启动 hexo 了。 1npm server # 或者是 npm s, 效果等价 这时会提示说在localhost:4000端口可以访问刚刚建立的博客，正常情况下，如果4000端口没有被占用的话，那么就可以正常访问到博客，会有一篇默认的Hello World的博文。如果4000端口被占用了，具体的表现就是网站打不开，那么可以尝试更换一个启动端口，具体命令可以自行搜索。 5. 部署到 Github Page在部署到 github page之前，需要在本地修改一些配置。 首先打开_config.yml，搜索deploy字段，修改为如下格式：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tanjuntao/tanjuntao.github.io.git branch: master 其中第二个repo字段的值，需要改为你在 github 上面那个网站项目对应的 SSH 值，也不打算截图介绍这个 SSH 值是怎么获取到的了。需要注意的是每个:后面需要紧跟一个空格，否则会出错！ 接着，在 git bash 中执行下面的命令：1npm install hexo-deployer-git --save 执行这条命令可能会出错，解决办法是 npm + flush刷新一下缓存, 具体的命令记不清楚。 最后就可以 deploy 到远程的 github 上面了。 1hexo deploy # 或者 hexo d, 效果是一样的 这时候，就可以看到 github 仓库里面生成了很多文件，但是找不到 source 文件夹，这就是前面介绍到的，保护了源文件。 要通过github账户名.github.io方式访问网站，还需要在项目仓库中的setting中设置中找到github page，设置一下后，才能够访问到。 6. 使用后面当需要新建一篇博文时，只需要做下面三个步骤，非常方便！1234hexo new &quot;博文标题&quot;hexo generate # hexo ghexo server # hexo s, 启动本地服务，可在本地中预览效果，这步可选hexo deploy # hexo d 7. 修改主题hexo 中默认使用的主题是landscape,但最为流行的一个主题叫next，打算安装next主题的可以接着往下看。 首先切换到博客更目录下面，也就是前面的blog/目录，执行下面命令：1git clone https://github.com/iissnan/hexo-theme-next themes/next 可能需要一段时间才能完成。 接着打开跟目录下面的_config.yml文件，修改theme字段的值为next就可以了。 如果后期打算更换其它主题，只需要修改这个theme的值就可以了，同样非常方便！ next主题默认的样式还是没有符合我的要求：左边有一个导航栏，且有关于 分类 标签 这些选项，我们还需要进一步对主题进行设置。 在/theme/next/目录中找到_config.yml文件，同样是一个设置文件，只不过仅仅是next这个主题的设置文件。 搜索Scheme，修改其值为Pisces或者Gemini，因为只有这两个 scheme 能显示左右侧边栏。 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 接着搜索sidebar，参考下列注释进行设置：12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 其它一些设置，包括头像，新页面，评论系统等，可以参见Hexo的Next主题详细配置 这篇文章，非常详细！ 8.其它关于使用 hexo deploy时，如何附带像git commit那样的message，只需要如下命令即可：1hexo deploy --message &quot;提交的信息内容&quot; 非常方便！ 9.注意事项 不要修改使用hexo new命令生成的文章标题 在编辑hexo new生成的 markdown 文件时，不要动手修改title的值，否则会导致这篇post无法显示在网站上！ 这篇文章就先到这里啦~ 主要参考 https://segmentfault.com/q/1010000007139908 https://www.jianshu.com/p/3a05351a37dc https://www.jianshu.com/p/40e4349a0cc7]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试博文]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B5%8B%E8%AF%95%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[二级标题：测试markdown语法的支持情况 有序列表 有序列表 无序列表 无序列表 这里是引用内容 123import tensorflow as tfimport numpy as npprint('hello world') 这是行内代码，这是加粗，这是斜体]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
